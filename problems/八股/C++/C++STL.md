## STLå®¹å™¨äº†è§£å“ªäº›

### ç®€è¦å›ç­”

C++ STL ä¸­ä¸»è¦æœ‰ä¸‰ç±»å®¹å™¨ï¼š

**é¡ºåºå®¹å™¨**ï¼ˆSequence Containersï¼‰ï¼šå¦‚ vector, list, deque, array, forward_list

**å…³è”å®¹å™¨**ï¼ˆAssociative Containersï¼‰ï¼šå¦‚ set, map, multiset, multimap

**æ— åºå®¹å™¨**ï¼ˆUnordered Containersï¼‰å“ˆå¸Œå®¹å™¨ï¼šå¦‚ unordered_map, unordered_set, unordered_multimap, unordered_multiset

æ­¤å¤–ï¼ŒSTL è¿˜åŒ…æ‹¬é…å¥—çš„**è¿­ä»£å™¨ã€ç®—æ³•ã€ä»¿å‡½æ•°ã€é€‚é…å™¨**ç­‰ç»„ä»¶ã€‚

### è¯¦ç»†å›ç­”

STLå®¹å™¨å¯åˆ†ä¸ºä¸‰å¤§ç±»ï¼š

**åºåˆ—å®¹å™¨ï¼šç»´æŠ¤å…ƒç´ çš„çº¿æ€§åºåˆ—**

vectorï¼šåŠ¨æ€æ•°ç»„ï¼Œæ”¯æŒå¿«é€Ÿéšæœºè®¿é—®

dequeï¼šåŒç«¯é˜Ÿåˆ—ï¼Œä¸¤ç«¯é«˜æ•ˆæ’å…¥/åˆ é™¤

listï¼šåŒå‘é“¾è¡¨ï¼Œä»»æ„ä½ç½®é«˜æ•ˆæ’å…¥/åˆ é™¤

forward_listï¼šå•å‘é“¾è¡¨ï¼Œæ›´èŠ‚çœç©ºé—´

arrayï¼šå›ºå®šå¤§å°æ•°ç»„ï¼Œæ›´å®‰å…¨çš„åŸç”Ÿæ•°ç»„æ›¿ä»£

**å…³è”å®¹å™¨ï¼šåŸºäºé”®å€¼å¯¹çš„æœ‰åºå­˜å‚¨**

set/multisetï¼šæœ‰åºå”¯ä¸€/éå”¯ä¸€é”®é›†åˆ

map/multimapï¼šæœ‰åºé”®å€¼å¯¹é›†åˆï¼Œé”®å”¯ä¸€/éå”¯ä¸€

**æ— åºå…³è”å®¹å™¨ï¼šåŸºäºå“ˆå¸Œè¡¨çš„å­˜å‚¨**

unordered_set/unordered_multiset

unordered_map/unordered_multimap

æ¯ç§å®¹å™¨åœ¨æ—¶é—´å¤æ‚åº¦ã€å†…å­˜å¸ƒå±€å’Œé€‚ç”¨åœºæ™¯ä¸Šæœ‰æ‰€ä¸åŒã€‚

STLçš„å®¹å™¨çš„ç‰¹ç‚¹å¦‚ä¸‹

- é¡ºåºå®¹å™¨

|å®¹å™¨|ç‰¹ç‚¹|
|---|---|
|`vector`|åŠ¨æ€æ•°ç»„ï¼Œéšæœºè®¿é—®å¿«ï¼Œå°¾éƒ¨æ’å…¥å¿«|
|`list`|åŒå‘é“¾è¡¨ï¼Œä»»æ„ä½ç½®æ’å…¥/åˆ é™¤å¿«|
|`deque`|åŒç«¯é˜Ÿåˆ—ï¼Œå¤´å°¾éƒ½èƒ½å¿«é€Ÿæ’å…¥/åˆ é™¤|
|`array`|å›ºå®šå¤§å°æ•°ç»„ï¼ˆC++11ï¼‰|
|`forward_list`|å•å‘é“¾è¡¨ï¼ˆC++11ï¼‰|

- å…³è”å®¹å™¨ï¼ˆæœ‰åºï¼ŒåŸºäºçº¢é»‘æ ‘ï¼‰

|å®¹å™¨|ç‰¹ç‚¹|
|---|---|
|`set`|å”¯ä¸€å…ƒç´ è‡ªåŠ¨æ’åº|
|`multiset`|å…ƒç´ å…è®¸é‡å¤|
|`map`|é”®å€¼å¯¹ï¼Œé”®å”¯ä¸€|
|`multimap`|é”®å€¼å¯¹ï¼Œé”®å¯é‡å¤|

- æ— åºå®¹å™¨ï¼ˆåŸºäºå“ˆå¸Œè¡¨ï¼ŒC++11ï¼‰

|å®¹å™¨|ç‰¹ç‚¹|
|---|---|
|`unordered_set`|æ— åºå”¯ä¸€é›†åˆ|
|`unordered_map`|æ— åºé”®å€¼å¯¹|
|`unordered_multiset`|æ— åºå¯é‡å¤é›†åˆ|
|`unordered_multimap`|æ— åºå¯é‡å¤é”®å€¼å¯¹|

### ä»£ç ç¤ºä¾‹

```cpp
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <unordered_map>
#include <list>
using namespace std;

int main() {
    vector<int> vec = {1, 2, 3};
    vec.push_back(4);  // åŠ¨æ€æ•°ç»„

    list<int> lst = {10, 20, 30};
    lst.push_front(5); // åŒå‘é“¾è¡¨

    set<int> s = {5, 2, 3, 2}; // è‡ªåŠ¨å»é‡æ’åº
    map<string, int> m = {{"Tom", 90}, {"Jerry", 85}}; // å­—å…¸

    unordered_map<string, int> um;
    um["apple"] = 3;
    um["banana"] = 5; // å“ˆå¸Œè¡¨

    return 0;
}
```

### çŸ¥è¯†æ‹“å±•

![image](https://file1.kamacoder.com/i/bagu/202507241.png)

- çŸ¥è¯†å›¾è§£
    
- æ‹“å±•
    

STLå®¹å™¨çš„åº•å±‚ç»“æ„ï¼š

vector, deque â†’ åŠ¨æ€æ•°ç»„

list, forward_list â†’ é“¾è¡¨

set, map â†’ çº¢é»‘æ ‘

unordered_* â†’ å“ˆå¸Œè¡¨

æ€§èƒ½å·®å¼‚ï¼ˆæ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ï¼‰ï¼š

vector éšæœºè®¿é—®å¿«ï¼Œä½†æ’å…¥æ…¢ï¼ˆä¸­é—´æ’å…¥éœ€ç§»åŠ¨å…ƒç´ ï¼‰

list æ’å…¥åˆ é™¤å¿«ï¼Œä½†ä¸æ”¯æŒéšæœºè®¿é—®

map/set æŸ¥æ‰¾ã€æ’å…¥éƒ½æ˜¯ O(logN)ï¼Œä½†æœ‰åº

unordered_map æŸ¥æ‰¾ã€æ’å…¥æ˜¯ O(1) å¹³å‡å¤æ‚åº¦

- ä½¿ç”¨åœºæ™¯

vectorï¼šéœ€è¦éšæœºè®¿é—®ã€åŠ¨æ€æ‰©å®¹çš„æƒ…å†µï¼ˆå¦‚å›¾åƒå¤„ç†ã€çº¿æ€§ç¼“å­˜ï¼‰

listï¼šé¢‘ç¹æ’å…¥åˆ é™¤æ•°æ®çš„åœºæ™¯ï¼ˆå¦‚ç¼–è¾‘å™¨æ’¤å›æ ˆï¼‰

map/unordered_mapï¼šæŸ¥æ‰¾ã€è®¡æ•°ã€å­—å…¸ã€é…ç½®è§£æï¼ˆå¦‚è®°å½•è®¿é—®æ¬¡æ•°ï¼‰

setï¼šéœ€è¦å»é‡ã€å”¯ä¸€æ€§åˆ¤æ–­ï¼ˆå¦‚ç”¨æˆ· ID é›†åˆï¼‰

dequeï¼šå®ç°æ»‘åŠ¨çª—å£ç®—æ³•ã€åŒç«¯é˜Ÿåˆ—ç¼“å­˜ï¼ˆå¦‚ LRUï¼‰

## vectorå’Œarrayçš„ä½¿ç”¨åœºæ™¯åˆ†åˆ«æ˜¯ä»€ä¹ˆï¼Ÿ ï¼ˆè€ƒç‚¹ï¼švectorä¸arrayçš„ä½¿ç”¨åœºæ™¯ï¼‰ã€ç®€å•ã€‘

### ä¸€ã€åŸºæœ¬ä»‹ç»

|ç‰¹æ€§|`std::vector`|`std::array`ï¼ˆC++11 å¼•å…¥ï¼‰|
|---|---|---|
|å¤§å°|åŠ¨æ€å¯å˜|å›ºå®šä¸å˜ï¼ˆç¼–è¯‘æ—¶ç¡®å®šï¼‰|
|å†…å­˜åˆ†é…|å †ï¼ˆåŠ¨æ€åˆ†é…ï¼‰|æ ˆï¼ˆé™æ€åˆ†é…ï¼‰|
|æ ‡å‡†åº“æ”¯æŒ|C++98 èµ·å°±æœ‰|C++11 èµ·å¼•å…¥|
|å…ƒç´ è®¿é—®|æ”¯æŒä¸‹æ ‡è®¿é—®å’Œè¿­ä»£å™¨|åŒæ ·æ”¯æŒ|
|æ•ˆç‡|ç¨æ…¢ï¼ˆæ¶‰åŠåŠ¨æ€åˆ†é…ï¼‰|æ›´å¿«ï¼ˆåœ¨æ ˆä¸Šåˆ†é…ï¼Œæ— éœ€é¢å¤–å¼€é”€ï¼‰|

---

### äºŒã€`std::vector`Â ä½¿ç”¨åœºæ™¯

> **é€‚ç”¨äºï¼šå…ƒç´ æ•°é‡è¿è¡Œæ—¶å˜åŒ–ã€é¢‘ç¹æ’å…¥åˆ é™¤ã€éœ€è¦è‡ªåŠ¨æ‰©å®¹çš„åœºæ™¯**

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> nums;
    for (int i = 0; i < 10; ++i) {
        nums.push_back(i); // åŠ¨æ€æ‰©å®¹
    }

    for (int n : nums) {
        std::cout << n << " ";
    }
    return 0;
}
```

#### åº”ç”¨åœºæ™¯ï¼š

- åŠ¨æ€è¯»å–ç”¨æˆ·è¾“å…¥æˆ–æ–‡ä»¶å†…å®¹ï¼ˆæ•°æ®é‡æœªçŸ¥ï¼‰
- ä½¿ç”¨ STL ç®—æ³•æ—¶éœ€è¦å¯å˜å®¹å™¨ï¼ˆå¦‚æ’åºï¼‰
- å®ç°å †æ ˆã€é˜Ÿåˆ—ã€å›¾ç­‰åŠ¨æ€ç»“æ„

---

### ä¸‰ã€`std::array`Â ä½¿ç”¨åœºæ™¯

> **é€‚ç”¨äºï¼šå…ƒç´ æ•°é‡å›ºå®šã€æ€§èƒ½è¦æ±‚é«˜ã€æ— éœ€æ‰©å®¹çš„åœºæ™¯**

```cpp
#include <iostream>
#include <array>

int main() {
    std::array<int, 5> nums = {1, 2, 3, 4, 5};

    for (int n : nums) {
        std::cout << n << " ";
    }
    return 0;
}
```

#### ğŸ”§ åº”ç”¨åœºæ™¯ï¼š

- ç¼–è¯‘æœŸå·²çŸ¥æ•°ç»„å¤§å°ï¼ˆå¦‚äº”ä¸ªæ–¹å‘å‘é‡ï¼‰
- ç®—æ³•ä¸­éœ€è¦æ›´å¿«çš„è®¿é—®é€Ÿåº¦
- åµŒå…¥å¼æˆ–é«˜æ€§èƒ½åœºæ™¯ä¸‹ä½¿ç”¨

#### å¯¹æ¯”ä¼ ç»Ÿæ•°ç»„çš„ä¼˜åŠ¿ï¼š

- æ”¯æŒ STL ç®—æ³•ã€è¿­ä»£å™¨
- ç±»å‹å®‰å…¨ï¼Œé¿å…é€€åŒ–ä¸ºæŒ‡é’ˆ

---

### å››ã€æ€»ç»“å¯¹æ¯” ğŸ¯

|ä½¿ç”¨éœ€æ±‚|æ¨èå®¹å™¨|
|---|---|
|éœ€è¦åŠ¨æ€å¢é•¿|`std::vector`|
|å›ºå®šé•¿åº¦ã€æ€§èƒ½æ•æ„Ÿ|`std::array`|
|ä½¿ç”¨æ—§Cé£æ ¼æ•°ç»„|åŸå§‹æ•°ç»„Â `T arr[N]`|
|ä¸Cæ¥å£äº¤äº’|åŸå§‹æ•°ç»„ æˆ–Â `std::vector::data()`|

## ä½ èƒ½æè¿°ä¸€ä¸‹vectoræ˜¯å¦‚ä½•ä¿è¯å…ƒç´ è¿ç»­å­˜å‚¨çš„å—ï¼Ÿ ï¼ˆè€ƒç‚¹ï¼švectorçš„å†…å­˜ç®¡ç†ï¼‰ã€ç®€å•ã€‘

vectorå†…éƒ¨ä½¿ç”¨**åŠ¨æ€æ•°ç»„**ä½œä¸ºåº•å±‚å­˜å‚¨ç»“æ„ï¼Œå†…éƒ¨ä½¿ç”¨äº†ä¸€ä¸ª**å•ä¸€çš„å†…å­˜å—**æ¥å­˜å‚¨æ‰€æœ‰çš„å…ƒç´ ï¼Œå¹¶ä¸”ç®¡ç†è¿™ä¸ªå†…å­˜å—çš„å¤§å°å’Œå®¹é‡ã€‚å½“vectorçš„å†…å­˜å®¹é‡ä¸å¤Ÿæ—¶ï¼Œä¼šé‡æ–°åˆ†é…ä¸€å—æ›´å¤§çš„å†…å­˜ï¼Œå†æŠŠæ—§çš„æ•°ç»„ä¸­çš„æ•°æ®å¤åˆ¶åˆ°æ–°çš„å†…å­˜å—ä¸­

## å½“vectorçš„ç©ºé—´ä¸è¶³ä»¥å®¹çº³æ›´å¤šå…ƒç´ æ—¶ï¼Œå®ƒæ˜¯å¦‚ä½•æ‰©å®¹çš„ï¼Ÿ ï¼ˆè€ƒç‚¹ï¼švectorçš„åŠ¨æ€æ‰©å®¹æœºåˆ¶ï¼‰ã€ä¸­ç­‰ã€‘

vectoråœ¨ç©ºé—´ä¸è¶³æ—¶ï¼Œä¼šè¿›è¡Œæ‰©å®¹ã€‚ vectorå†…éƒ¨å®ç°äº†ä¸€ä¸ªå†…å­˜åˆ†é…å‡½æ•° å†…å­˜ä¸å¤Ÿæ—¶ä¼šç”³è¯·ä¸€å—åŸå†…å­˜1.5-2å€å¤§å°çš„æ–°å—ï¼Œå†æŠŠæ—§çš„æ•°ç»„å¤åˆ¶åˆ°æ–°çš„å†…å­˜ä¸­

vectoræ‰©å®¹æ—¶ï¼Œæ˜¯ä½¿ç”¨ç§»åŠ¨è¯­ä¹‰å¤åˆ¶å¯¹è±¡è¿˜æ˜¯ç›´æ¥æ‹·è´å¯¹è±¡ï¼Œå–å†³äºå¯¹è±¡æ˜¯å¦æ”¯æŒç§»åŠ¨è¯­ä¹‰ï¼Œå®ç°äº†ç§»åŠ¨æ„é€ å‡½æ•°

## vectorçš„push_backå’Œemplace_backæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ ï¼ˆè€ƒç‚¹ï¼švectorçš„å…ƒç´ æ·»åŠ æ–¹å¼ï¼‰ã€ç®€å•ã€‘

#### ã€ç®€è¦å›ç­”ã€‘

std::vectorçš„push_backå’Œemplace_backéƒ½ç”¨äºåœ¨å‘é‡çš„æœ«å°¾æ·»åŠ å…ƒç´ ï¼Œä½†å®ƒä»¬æ·»åŠ å…ƒç´ çš„æ–¹å¼ä¸åŒï¼š

- `push_back`ï¼šåˆ›å»ºä¸€ä¸ªå…ƒç´ çš„å‰¯æœ¬æˆ–ç§»åŠ¨è¯¥å…ƒç´ ï¼Œç„¶åå°†å…¶æ·»åŠ åˆ°å‘é‡çš„æœ«å°¾ã€‚
- `emplace_back`ï¼šåœ¨å‘é‡çš„æœ«å°¾å°±åœ°æ„é€ å…ƒç´ ï¼Œé¿å…äº†é¢å¤–çš„å¤åˆ¶æˆ–ç§»åŠ¨ã€‚

#### ã€è¯¦ç»†å›ç­”ã€‘

**push_back**ï¼š

- push_backæ–¹æ³•æ¥å—ä¸€ä¸ªå‚æ•°ï¼Œè¯¥å‚æ•°å¯ä»¥æ˜¯ä¸€ä¸ªå€¼ã€ä¸€ä¸ªå·²å­˜åœ¨çš„å¯¹è±¡çš„å¼•ç”¨ï¼Œæˆ–è€…æ˜¯è¦æ·»åŠ åˆ°å‘é‡æœ«å°¾çš„å…ƒç´ çš„å³å€¼ã€‚
- å¦‚æœå‚æ•°æ˜¯ä¸€ä¸ªå³å€¼ï¼Œpush_backå°†ä½¿ç”¨ç§»åŠ¨æ„é€ å‡½æ•°ï¼ˆå¦‚æœå¯ç”¨ï¼‰æ¥ç§»åŠ¨å®ƒï¼›å¦‚æœå‚æ•°æ˜¯ä¸€ä¸ªå·¦å€¼ï¼Œå®ƒå°†ä½¿ç”¨å¤åˆ¶æ„é€ å‡½æ•°æ¥å¤åˆ¶å®ƒã€‚
- push_backåœ¨å‘é‡éœ€è¦æ‰©å®¹æ—¶ï¼Œå¯èƒ½ä¼šå¯¼è‡´å‘é‡ä¸­çš„æ‰€æœ‰å…ƒç´ è¢«å¤åˆ¶æˆ–ç§»åŠ¨åˆ°æ–°çš„å†…å­˜ä½ç½®ã€‚

**emplace_back**ï¼š

- emplace_backä¸æ¥å—ä»»ä½•ç›´æ¥çš„å‚æ•°ï¼Œä½†å®ƒæ¥å—æ„é€ æ–°å…ƒç´ æ‰€éœ€çš„å‚æ•°ï¼Œå¹¶ä½¿ç”¨è¿™äº›å‚æ•°åˆ—è¡¨åœ¨å‘é‡çš„æœ«å°¾å°±åœ°æ„é€ ä¸€ä¸ªæ–°å…ƒç´ ã€‚
- emplace_backé¿å…äº†ä¸´æ—¶å¯¹è±¡çš„åˆ›å»ºå’Œé”€æ¯ï¼Œå› ä¸ºå®ƒç›´æ¥åœ¨å‘é‡å†…å­˜ç©ºé—´å†…æ„é€ å¯¹è±¡ã€‚
- emplace_backä¸ä¼šè§¦å‘å‘é‡å†…å­˜çš„é‡æ–°åˆ†é…ï¼Œé™¤éå‘é‡å·²ç»è¾¾åˆ°äº†å®ƒçš„å®¹é‡ä¸Šé™ã€‚

#### ã€çŸ¥è¯†æ‹“å±•ã€‘

1. æ€§èƒ½ï¼šemplace_backé€šå¸¸æ¯”push_backæ›´é«˜æ•ˆï¼Œå› ä¸ºå®ƒçœå»äº†ä¸´æ—¶å¯¹è±¡çš„åˆ›å»ºå’Œé”€æ¯çš„å¼€é”€ï¼Œç‰¹åˆ«æ˜¯åœ¨æ„é€ å’Œææ„æˆæœ¬è¾ƒé«˜æ—¶ã€‚
    
2. é€‚ç”¨åœºæ™¯ï¼šå½“ä½ éœ€è¦ä¼ é€’å¤šä¸ªå‚æ•°æ¥æ„é€ å‘é‡æœ«å°¾çš„å…ƒç´ æ—¶ï¼Œemplace_backæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ï¼Œå› ä¸ºå®ƒå…è®¸ä½ ç›´æ¥ä¼ é€’è¿™äº›å‚æ•°ç»™æ„é€ å‡½æ•°ã€‚
    
3. å®Œç¾è½¬å‘ï¼šemplace_backèƒ½å¤Ÿå®Œç¾è½¬å‘å‚æ•°ï¼Œè¿™æ„å‘³ç€å‚æ•°çš„å€¼ç±»åˆ«ï¼ˆå·¦å€¼ã€å³å€¼ï¼‰ä¼šè¢«ä¿ç•™ï¼Œè¿™å¯¹äºéœ€è¦åŒºåˆ†å¤„ç†å·¦å€¼å’Œå³å€¼çš„æ„é€ å‡½æ•°ç‰¹åˆ«æœ‰ç”¨ã€‚
    
4. å†…å­˜åˆ†é…ï¼špush_backåœ¨æ·»åŠ å…ƒç´ æ—¶å¯èƒ½ä¼šè§¦å‘å†…å­˜åˆ†é…ï¼Œå› ä¸ºå‘é‡å¯èƒ½éœ€è¦æ‰©å®¹ï¼›è€Œemplace_backåªæœ‰åœ¨å‘é‡å®¹é‡ä¸è¶³ä»¥å®¹çº³æ–°å…ƒç´ æ—¶æ‰ä¼šè§¦å‘å†…å­˜åˆ†é…ã€‚
    

```cpp
#include <vector>
#include <string>

int main() {
   std::vector<std::string> v;

   // ä½¿ç”¨push_backæ·»åŠ å…ƒç´ 
   v.push_back("Copy or move this string");

   // ä½¿ç”¨emplace_backå°±åœ°æ„é€ å…ƒç´ 
   v.emplace_back("Constructed in place");

   return 0;
}
```

## listå’Œvectoræœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ ï¼ˆè€ƒç‚¹ï¼šlistä¸vectorçš„æ¯”è¾ƒï¼‰ã€ä¸­ç­‰ã€‘

#### listå’Œvectoræœ‰ä»€ä¹ˆåŒºåˆ«

1. **åº•å±‚æ•°æ®ç»“æ„**ï¼š
    - vectorï¼šåŠ¨æ€æ•°ç»„ï¼Œåœ¨å†…å­˜ä¸­æ˜¯è¿ç»­å­˜å‚¨çš„ã€‚
    - listï¼šåŒå‘é“¾è¡¨ï¼Œæ¯ä¸ªå…ƒç´ å­˜å‚¨åœ¨ä¸è¿ç»­çš„å†…å­˜å—ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«æŒ‡å‘å‰ä¸€ä¸ªå…ƒç´ å’Œåä¸€ä¸ªå…ƒç´ çš„æŒ‡é’ˆã€‚
2. **éšæœºè®¿é—®**ï¼š
    - vectorï¼šæ”¯æŒé«˜æ•ˆçš„éšæœºè®¿é—®ï¼ˆO(1)ï¼‰ï¼Œå› ä¸ºé€šè¿‡ç´¢å¼•è®¡ç®—åœ°å€æ˜¯å¸¸é‡æ—¶é—´ã€‚
    - listï¼šä¸æ”¯æŒéšæœºè®¿é—®ï¼Œè®¿é—®ç¬¬nä¸ªå…ƒç´ éœ€è¦éå†é“¾è¡¨ï¼ˆO(n)ï¼‰ã€‚
3. **æ’å…¥å’Œåˆ é™¤æ“ä½œ**ï¼š
    - vectorï¼š
    - åœ¨å°¾éƒ¨æ’å…¥æˆ–åˆ é™¤ï¼šå¹³å‡O(1)
    - åœ¨ä¸­é—´æˆ–å¤´éƒ¨æ’å…¥æˆ–åˆ é™¤ï¼šO(n)ï¼Œå› ä¸ºéœ€è¦ç§»åŠ¨å…ƒç´ ã€‚
    - listï¼š
    - åœ¨ä»»æ„ä½ç½®æ’å…¥æˆ–åˆ é™¤ï¼šæ“ä½œæ˜¯O(1)ï¼Œå› ä¸ºåªéœ€è¦è°ƒæ•´æŒ‡é’ˆã€‚
    - ä½†æ˜¯ï¼Œæ‰¾åˆ°æ’å…¥ä½ç½®å¯èƒ½éœ€è¦O(n)ï¼ˆé™¤éå·²ç»æ‹¥æœ‰è¯¥ä½ç½®çš„è¿­ä»£å™¨ï¼‰ã€‚
4. è¿­ä»£å™¨ï¼š
    - vectorï¼šéšæœºè®¿é—®è¿­ä»£å™¨ï¼Œæ”¯æŒæ‰€æœ‰è¿­ä»£å™¨æ“ä½œï¼ˆåŒ…æ‹¬åŠ å‡æ•´æ•°ç­‰ï¼‰ã€‚
    - listï¼šåŒå‘è¿­ä»£å™¨ï¼Œåªæ”¯æŒå‰ç§»å’Œåç§»ï¼ˆ++å’Œ--ï¼‰ï¼Œä¸æ”¯æŒéšæœºè®¿é—®ï¼ˆå¦‚it+5ï¼‰ã€‚
5. **ä½¿ç”¨åœºæ™¯**ï¼š
    - vectorï¼šå½“éœ€è¦é¢‘ç¹éšæœºè®¿é—®ï¼Œæˆ–è€…ä¸»è¦åœ¨**å°¾éƒ¨**æ·»åŠ /åˆ é™¤å…ƒç´ æ—¶ä½¿ç”¨ã€‚
    - listï¼šå½“éœ€è¦åœ¨**å®¹å™¨ä¸­é—´**é¢‘ç¹æ’å…¥å’Œåˆ é™¤ï¼Œå¹¶ä¸”ä¸éœ€è¦éšæœºè®¿é—®æ—¶ä½¿ç”¨ã€‚
6. **é€Ÿåº¦**ï¼š
    - vectorï¼šä½¿ç”¨**è¿ç»­å†…å­˜**åˆ†é…ï¼Œå¯ä»¥åˆ©ç”¨ç¼“å­˜çš„ä¼˜åŠ¿ï¼Œæé«˜è®¿é—®é€Ÿåº¦ã€‚è¿™ä¸»è¦åŸºäºè®¡ç®—æœºç³»ç»Ÿä¸­ç¼“å­˜çš„å·¥ä½œåŸç†å’Œå±€éƒ¨æ€§åŸç†ï¼Œå±€éƒ¨æ€§åŸç†æ˜¯å¦‚æœæŸä¸ªæ•°æ®è¢«è®¿é—®ï¼Œé‚£ä¹ˆä¸ä¹…ä¹‹åå®ƒå¾ˆå¯èƒ½å†æ¬¡è¢«è®¿é—®ï¼Œå®ƒç›¸é‚»çš„æ•°æ®ä¹Ÿå¾ˆå¯èƒ½å¾ˆå¿«è¢«è®¿é—®ã€‚`std::vector`çš„è¿ç»­å†…å­˜å¸ƒå±€å¤©ç„¶ç¬¦åˆç©ºé—´å±€éƒ¨æ€§ã€‚å½“ç¨‹åºè®¿é—®ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œç›¸é‚»å…ƒç´ æœ‰å¾ˆå¤§æ¦‚ç‡ä¹Ÿä¼šè¢«è®¿é—®ï¼ˆä¾‹å¦‚éå†æ•°ç»„ï¼‰ï¼Œå› æ­¤ç¼“å­˜ä¼šä¸€æ¬¡æ€§åŠ è½½ä¸€æ•´ä¸ªç¼“å­˜è¡Œåˆ°é«˜é€Ÿç¼“å­˜ä¸­ï¼Œåç»­è®¿é—®åŒä¸€ç¼“å­˜è¡Œå†…çš„æ•°æ®æ—¶ï¼Œç›´æ¥å‘½ä¸­é«˜é€Ÿç¼“å­˜ï¼Œé€Ÿåº¦éå¸¸å¿«ã€‚
    - listï¼šèŠ‚ç‚¹**åˆ†æ•£åœ¨å †å†…å­˜**å„å¤„ï¼Œè®¿é—®ä¸‹ä¸€ä¸ªå…ƒç´ éœ€è·³è½¬æŒ‡é’ˆï¼ˆè€Œä¸”å¯èƒ½è·¨è¶Šä¸åŒå†…å­˜é¡µï¼‰ï¼Œæ¯æ¬¡è®¿é—®å‡ ä¹éƒ½ä¼šå¯¼è‡´ç¼“å­˜æœªå‘½ä¸­ï¼Œè¦é‡æ–°è®¿é—®ä¸»å­˜ï¼Œé€Ÿåº¦å°±æ…¢ã€‚

## listæ˜¯å¦‚ä½•å®ç°å…ƒç´ çš„æ’å…¥å’Œåˆ é™¤çš„ï¼Ÿ ï¼ˆè€ƒç‚¹ï¼šlistçš„å…ƒç´ æ“ä½œï¼‰ã€ä¸­ç­‰ã€‘

liståº•å±‚æ˜¯åŒé“¾è¡¨ï¼Œä½¿ç”¨æŒ‡é’ˆé“¾æ¥å…ƒç´ çš„ä¸‹ä¸€ä¸ªå’Œä¸Šä¸€ä¸ªå…ƒç´ ï¼Œæ”¯æŒåŒå‘éå†

æ’å…¥å’Œåˆ é™¤å…ƒç´ ä½¿ç”¨çš„å°±æ˜¯åŒé“¾è¡¨çš„æ’å…¥å’Œåˆ é™¤ï¼Œä¿®æ”¹æŒ‡é’ˆç´¢å¼•

## setçš„åº•å±‚å®ç°ä¸mapæœ‰ä»€ä¹ˆä¸åŒï¼Ÿ ï¼ˆè€ƒç‚¹ï¼šsetçš„åº•å±‚æ•°æ®ç»“æ„ï¼‰ã€ä¸­ç­‰ã€‘

std::setå’Œstd::mapåœ¨C++æ ‡å‡†åº“ä¸­éƒ½æ˜¯åŸºäºå¹³è¡¡äºŒå‰æ ‘ï¼ˆé€šå¸¸æ˜¯çº¢é»‘æ ‘ï¼‰å®ç°çš„ã€‚ä¸»è¦åŒºåˆ«åœ¨äºï¼š

std::setä»…å­˜å‚¨é”®å€¼ï¼Œè€Œstd::mapå­˜å‚¨é”®å€¼å¯¹ã€‚

std::setçš„é”®å€¼å³ä¸ºå…ƒç´ æœ¬èº«ï¼Œè€Œstd::mapçš„é”®å€¼æ˜¯é”®ï¼Œå€¼æ˜¯ä¸é”®ç›¸å…³è”çš„æ•°æ®ã€‚

## mapã€setã€multimapã€multisetæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ ï¼ˆè€ƒç‚¹ï¼šå…³è”å®¹å™¨çš„æ¯”è¾ƒï¼‰ã€ä¸­ç­‰ã€‘

C++ä¸­çš„std::mapã€std::setã€std::multimapå’Œstd::multisetéƒ½æ˜¯æ ‡å‡†åº“ä¸­çš„å…³è”å®¹å™¨ï¼Œå®ƒä»¬éƒ½åŸºäºçº¢é»‘æ ‘å®ç°ã€‚ä»¥ä¸‹æ˜¯è¿™äº›å®¹å™¨çš„è¯¦ç»†åŒºåˆ«ï¼š

1.`std::map`

- é”®å€¼å¯¹å­˜å‚¨ï¼šstd::mapå­˜å‚¨é”®å€¼å¯¹ï¼ˆstd::pair<const Key, T>ï¼‰ï¼Œå…¶ä¸­Keyæ˜¯é”®ï¼ŒTæ˜¯ä¸é”®ç›¸å…³è”çš„å€¼ã€‚
- é”®çš„å”¯ä¸€æ€§ï¼šæ¯ä¸ªé”®åœ¨mapä¸­æ˜¯å”¯ä¸€çš„ï¼Œä¸å…è®¸æœ‰é‡å¤çš„é”®ã€‚
- æ’åºï¼šmapä¸­çš„å…ƒç´ æ ¹æ®é”®è‡ªåŠ¨æ’åºã€‚
- è®¿é—®ï¼šé€šè¿‡é”®è®¿é—®å€¼ï¼Œä½¿ç”¨ä¸‹æ ‡æ“ä½œç¬¦operator[]å¯ä»¥ç›´æ¥è®¿é—®æˆ–æ·»åŠ å…ƒç´ ã€‚

2. `std::set`

- ä»…å­˜å‚¨é”®ï¼šstd::setåªå­˜å‚¨é”®ï¼ˆå…ƒç´ ï¼‰ï¼Œä¸å­˜å‚¨å€¼ã€‚
- å…ƒç´ å”¯ä¸€æ€§ï¼šæ¯ä¸ªå…ƒç´ åœ¨setä¸­æ˜¯å”¯ä¸€çš„ï¼Œä¸å…è®¸æœ‰é‡å¤çš„å…ƒç´ ã€‚
- æ’åºï¼šsetä¸­çš„å…ƒç´ æ ¹æ®å…ƒç´ å€¼è‡ªåŠ¨æ’åºã€‚
- è®¿é—®ï¼šåªèƒ½é€šè¿‡è¿­ä»£å™¨è®¿é—®å…ƒç´ ï¼Œä¸æ”¯æŒä¸‹æ ‡æ“ä½œç¬¦ã€‚

3.`std::multimap`

- é”®å€¼å¯¹å­˜å‚¨ï¼šstd::multimapå­˜å‚¨é”®å€¼å¯¹ï¼Œä¸mapç±»ä¼¼ï¼Œä½†æ˜¯å…è®¸æœ‰é‡å¤çš„é”®ã€‚
- é”®çš„é‡å¤æ€§ï¼šå…è®¸å¤šä¸ªå…ƒç´ å…·æœ‰ç›¸åŒçš„é”®ã€‚
- æ’åºï¼šmultimapä¸­çš„å…ƒç´ æ ¹æ®é”®è‡ªåŠ¨æ’åºï¼Œå¯¹äºå…·æœ‰ç›¸åŒé”®çš„å…ƒç´ ï¼Œå®ƒä»¬åœ¨å†…éƒ¨æ˜¯æœ‰åºçš„ï¼ˆé€šå¸¸æ˜¯æ’å…¥é¡ºåºï¼‰ã€‚
- è®¿é—®ï¼šé€šè¿‡é”®è®¿é—®å€¼ï¼Œä½†ä¸èƒ½ç›´æ¥è®¿é—®ç‰¹å®šé”®çš„æ‰€æœ‰å€¼ï¼Œéœ€è¦éå†ã€‚

4.`std::multiset`

- ä»…å­˜å‚¨é”®ï¼šstd::multisetåªå­˜å‚¨é”®ï¼ˆå…ƒç´ ï¼‰ï¼Œä¸setç±»ä¼¼ï¼Œä½†æ˜¯å…è®¸æœ‰é‡å¤çš„å…ƒç´ ã€‚
- å…ƒç´ çš„é‡å¤æ€§ï¼šå…è®¸å¤šä¸ªå…ƒç´ å…·æœ‰ç›¸åŒçš„å€¼ã€‚
- æ’åºï¼šmultisetä¸­çš„å…ƒç´ æ ¹æ®å…ƒç´ å€¼è‡ªåŠ¨æ’åºï¼Œå¯¹äºå…·æœ‰ç›¸åŒå€¼çš„å…ƒç´ ï¼Œå®ƒä»¬åœ¨å†…éƒ¨æ˜¯æœ‰åºçš„ï¼ˆé€šå¸¸æ˜¯æ’å…¥é¡ºåºï¼‰ã€‚
- è®¿é—®ï¼šåªèƒ½é€šè¿‡è¿­ä»£å™¨è®¿é—®å…ƒç´ ï¼Œä¸æ”¯æŒä¸‹æ ‡æ“ä½œç¬¦ã€‚

## å¦‚ä½•åœ¨mapå’Œsetä¸­æŸ¥æ‰¾å…ƒç´ ï¼Ÿ ï¼ˆè€ƒç‚¹ï¼šå…ƒç´ æŸ¥æ‰¾ï¼‰ã€ç®€å•ã€‘

#### ã€ç®€è¦å›ç­”ã€‘

- **`find`Â æ–¹æ³•**ï¼šç›´æ¥æŸ¥æ‰¾ç‰¹å®šé”®çš„å€¼ï¼Œè¿”å›æŒ‡å‘è¯¥å…ƒç´ çš„è¿­ä»£å™¨ï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å›`end()`è¿­ä»£å™¨ã€‚
- **`count`Â æ–¹æ³•**ï¼šè¿”å›å…·find æ–¹æ³•ï¼Œç”±äºé”®çš„å”¯ä¸€æ€§ï¼Œè¿”å›å€¼è¦ä¹ˆæ˜¯0ï¼ˆæœªæ‰¾åˆ°ï¼‰ï¼Œè¦ä¹ˆæ˜¯1ï¼ˆæ‰¾åˆ°ï¼‰ã€‚
- **`lower_bound` æ–¹æ³•**ï¼šè¿”å›æŒ‡å‘ä¸å°äºç»™å®šé”®çš„é¦–ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚
- **`upper_bound`Â æ–¹æ³•**ï¼šè¿”å›æŒ‡å‘å¤§äºç»™å®šé”®çš„é¦–ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚
- **`equal_range` æ–¹æ³•**ï¼šè¿”å›ä¸€ä¸ªè¿­ä»£å™¨å¯¹ï¼ŒåŒ…æ‹¬lower_boundå’Œupper_boundï¼Œå¯¹äºä¸å­˜åœ¨çš„é”®ï¼Œè¿™ä¸¤ä¸ªè¿­ä»£å™¨æ˜¯ç›¸åŒçš„ã€‚å¯¹äºå”¯ä¸€é”®ï¼Œä¸ä¼šè¿”å›ç›¸åŒå€¼

#### è¯¦ç»†å›ç­”

**std::map**

1. find æ–¹æ³•ï¼š

- ç›´æ¥ä½¿ç”¨ find æ–¹æ³•æŸ¥æ‰¾ç‰¹å®šé”®çš„å€¼ã€‚
- å¦‚æœæ‰¾åˆ°äº†ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘è¯¥å…ƒç´ çš„è¿­ä»£å™¨ï¼›å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘ end() çš„è¿­ä»£å™¨ã€‚

```cpp
std::map<int, std::string> myMap;
myMap[1] = "one";
myMap[2] = "two";

auto it = myMap.find(1);
if (it != myMap.end()) {
    std::cout << "Found: " << it->second << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

2. count æ–¹æ³•ï¼š

- count æ–¹æ³•ç”¨äºè¿”å›å…·æœ‰ç‰¹å®šé”®çš„å…ƒç´ æ•°é‡ã€‚ç”±äº std::map ä¸­çš„é”®æ˜¯å”¯ä¸€çš„ï¼Œæ‰€ä»¥è¿”å›å€¼è¦ä¹ˆæ˜¯0ï¼ˆæœªæ‰¾åˆ°ï¼‰ï¼Œè¦ä¹ˆæ˜¯1ï¼ˆæ‰¾åˆ°ï¼‰ã€‚

```cpp
size_t count = myMap.count(1);
if (count > 0) {
    std::cout << "Found" << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

3. lower_bound å’Œ upper_bound æ–¹æ³•ï¼š

- lower_bound è¿”å›æŒ‡å‘ä¸å°äºç»™å®šé”®çš„é¦–ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚
- upper_bound è¿”å›æŒ‡å‘å¤§äºç»™å®šé”®çš„é¦–ä¸ªå…ƒç´ çš„è¿­ä»£å™¨

```cpp
auto lower = myMap.lower_bound(1);
auto upper = myMap.upper_bound(1);
if (lower != upper) {
    std::cout << "Found: " << lower->second << std::endl;
}
```

4. equal_range æ–¹æ³•ï¼š

equal_range è¿”å›ä¸€ä¸ªè¿­ä»£å™¨å¯¹ï¼Œç¬¬ä¸€ä¸ªæ˜¯ lower_boundï¼Œç¬¬äºŒä¸ªæ˜¯ upper_boundã€‚

```cpp
auto range = myMap.equal_range(1);
if (range.first != range.second) {
    std::cout << "Found: " << range.first->second << std::endl;
}
```

##### std::set

1. find æ–¹æ³•ï¼š

```cpp
std::set<int> mySet;
mySet.insert(1);
mySet.insert(2);

auto it = mySet.find(1);
if (it != mySet.end()) {
    std::cout << "Found" << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

2. count æ–¹æ³•ï¼š

```cpp
size_t count = mySet.count(1);
if (count > 0) {
    std::cout << "Found" << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

3. lower_bound å’Œ upper_bound æ–¹æ³•ï¼š

```cpp
auto lower = mySet.lower_bound(1);
auto upper = mySet.upper_bound(1);
if (lower != upper) {
    std::cout << "Found" << std::endl;
}
```

4. equal_range æ–¹æ³•ï¼š

```cpp
auto range = mySet.equal_range(1);
if (range.first != range.second) {
    std::cout << "Found" << std::endl;
}
```

## å®¹å™¨ map ã€dequeã€listçš„å®ç°åŸç†ï¼Ÿï¼ˆè€ƒç‚¹ï¼šmap ã€dequeã€listçš„åº•å±‚æ•°æ®ç»“æ„ï¼‰ã€ç®€å•ã€‘

- std::map:
    
    - åŸºäºçº¢é»‘æ ‘ï¼š`std:::map`æ˜¯åŸºäºçº¢é»‘æ ‘å®ç°çš„ï¼Œå®ƒä¿è¯å…ƒç´ æŒ‰é”®çš„é¡ºåºè¿›è¡Œæ’åºã€‚æ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨äº†é”®å€¼å¯¹ï¼Œå¹¶æ ¹æ®é”®çš„æ¯”è¾ƒç»“æœè¿›è¡Œè‡ªå¹³è¡¡ã€‚çº¢é»‘æ ‘æ˜¯ä¸€ç§è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œå®ƒé€šè¿‡é¢œè‰²å’ŒèŠ‚ç‚¹çš„ç‰¹å®šæ’åˆ—ä¿æŒå¹³è¡¡
    - æœ‰åºå®¹å™¨ï¼šå…ƒç´ æŒ‰ç…§é”®çš„é¡ºåºè‡ªåŠ¨ æ’åºï¼Œé€šå¸¸æ˜¯æŒ‰ç…§å°äºè¿ç®—ç¬¦å®šä¹‰çš„é¡ºåº
    - å”¯ä¸€é”®ï¼šæ¯ä¸ªé”®æ˜¯å”¯ä¸€çš„ï¼Œä¸å…è®¸æœ‰é‡å¤çš„é”®
    - æ—¶é—´å¤æ‚åº¦ï¼šæä¾›å¯¹æ•°æ—¶é—´å¤æ‚åº¦(O(logn))çš„æŸ¥æ‰¾ã€æ’å…¥å–åˆ é™¤æ“ä½œ
    - è¿­ä»£å™¨ï¼šç”±äºmapæ˜¯åŸºäºæ ‘çš„ï¼Œè¿­ä»£å™¨åœ¨éå†æ—¶æ˜¯æœ‰åºçš„
- std::deque:
    
    - std::deque:æ˜¯ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—ï¼Œå…è®¸åœ¨å®¹å™¨çš„ä¸¤ç«¯è¿›è¡Œå¿«é€Ÿçš„æ’å…¥å’Œåˆ é™¤æ“ä½œ
    - å®ƒé€šå¸¸æ˜¯åŸºäºä¸€ä¸ªèŠ‚ç‚¹æ•°ç»„å®ç°çš„ï¼Œæ¯ä¸ªèŠ‚ç‚¹å­˜å‚¨ä¸€éƒ¨åˆ†å…ƒç´ å¹¶å¯ä»¥åŠ¨æ€çš„å¢åŠ æˆ–åˆ é™¤èŠ‚ç‚¹
    - å…è®¸åºåˆ—æ“ä½œï¼šå¯ä»¥å¿«é€Ÿåœ°åœ¨é˜Ÿåˆ—çš„å‰ç«¯å’Œåç«¯æ·»åŠ æˆ–åˆ é™¤å…ƒç´ 
    - æ—¶é—´å¤æ‚åº¦ï¼šæä¾›å¸¸æ•°æ—¶é—´å¤æ‚åº¦çš„å‰ç«¯å’Œåç«¯æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚ä¸­é—´æ’å…¥å’Œåˆ é™¤æ“ä½œå¯èƒ½éœ€è¦O(n)
- std::list:
    
    - std::list:æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œæä¾›äº†åœ¨ä»»æ„ä½ç½®å¿«é€Ÿæ’å…¥å’Œåˆ é™¤å…ƒç´ çš„èƒ½åŠ›ã€‚ æ¯ä¸ªèŠ‚ç‚¹åŒ…å«æ•°æ®å’Œä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘å‰ä¸€ä¸ªç»“ç‚¹å’Œåä¸€ä¸ªèŠ‚ç‚¹
    - æ— åºå®¹å™¨ï¼šå…ƒç´ åœ¨å®¹å™¨ä¸­æ²¡æœ‰ç‰¹å®šçš„é¡ºåº
    - æ’å…¥å’Œåˆ é™¤ï¼šæä¾›é«˜æ•ˆçš„æ’å…¥å’Œåˆ é™¤æ“ä½œï¼Œç‰¹åˆ«æ˜¯å½“éœ€è¦åœ¨å®¹å™¨ä¸­é—´æ’å…¥å’Œåˆ é™¤æ—¶
    - æ—¶é—´å¤æ‚åº¦ï¼šæä¾›çº¿æ€§æ—¶é—´å¤æ‚åº¦O(n)çš„æŸ¥æ‰¾æ“ä½œï¼Œä½†æ’å…¥å’Œåˆ é™¤å¯ä»¥åœ¨O(1)æ—¶é—´å†…å®Œæˆï¼Œå‰ææ˜¯å·²ç»æ‹¥æœ‰æŒ‡å‘å¾…æ’å…¥æˆ–åˆ é™¤å…ƒç´ çš„è¿­ä»£å™¨
    - è¿­ä»£å™¨ï¼šç”±äºstd::listæ˜¯çº¿æ€§ç»“æ„ï¼Œè¿­ä»£å™¨åœ¨éå†æ—¶æ˜¯é¡ºåºçš„ï¼Œä½†ä¸æ”¯æŒéšæœºè®¿é—®

## map && unordered_mapçš„åŒºåˆ«å’Œå®ç°æœºåˆ¶ ï¼ˆè€ƒç‚¹ï¼šmap å’Œ unordered_mapçš„åŒºåˆ«ï¼‰ã€ç®€å•ã€‘

mapåº•å±‚æ˜¯åŸºäºçº¢â¿Šæ ‘å®ç°çš„ï¼Œå› æ­¤mapå†…éƒ¨å…ƒç´ æ’åˆ—æ˜¯æœ‰åºçš„ã€‚ â½½unordered_mapåº•å±‚åˆ™æ˜¯åŸºäºå“ˆå¸Œè¡¨å®ç°çš„ï¼Œå› æ­¤å…¶å…ƒç´ çš„æ’åˆ—é¡ºåºæ˜¯æ‚ä¹±â½†åºçš„ã€‚

## è¿­ä»£å™¨åœ¨STLä¸­æ‰®æ¼”ä»€ä¹ˆè§’è‰²ï¼Ÿ ï¼ˆè€ƒç‚¹ï¼šè¿­ä»£å™¨çš„ä½œç”¨ï¼‰ã€ç®€å•ã€‘

åœ¨C++çš„STLï¼ˆæ ‡å‡†æ¨¡æ¿åº“ï¼‰ä¸­ï¼Œè¿­ä»£å™¨æä¾›äº†ä¸€ç§ç»Ÿä¸€çš„æ–¹æ³•æ¥éå†ä¸åŒå®¹å™¨ä¸­çš„å…ƒç´ ï¼Œè€Œæ— éœ€äº†è§£å®¹å™¨çš„å†…éƒ¨ç»“æ„ï¼Œæ˜¯å®¹å™¨æ— å…³çš„ã€‚è¿­ä»£å™¨å¯ä»¥è¢«è§†ä¸ºæŒ‡å‘å®¹å™¨ä¸­æŸä¸ªç‰¹å®šä½ç½®çš„æŒ‡é’ˆï¼Œå…è®¸ç¨‹åºè®¿é—®å’Œæ“ä½œå®¹å™¨ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚

## ä»€ä¹ˆæ˜¯è¿­ä»£å™¨å¤±æ•ˆï¼Œå¦‚ä½•é¿å…ï¼Ÿ ï¼ˆè€ƒç‚¹ï¼šè¿­ä»£å™¨å¤±æ•ˆï¼‰ã€ä¸­ç­‰ã€‘

**è¿­ä»£å™¨å¤±æ•ˆï¼ˆiterator invalidationï¼‰**Â æŒ‡çš„æ˜¯ï¼šå®¹å™¨åœ¨æ‰§è¡ŒæŸäº›ä¿®æ”¹æ“ä½œåï¼Œ**åŸå…ˆæŒæœ‰çš„è¿­ä»£å™¨ / æŒ‡é’ˆ / å¼•ç”¨**Â ä¸å†æŒ‡å‘æœ‰æ•ˆå…ƒç´ ï¼Œç»§ç»­ä½¿ç”¨å°†äº§ç”Ÿæœªå®šä¹‰è¡Œä¸ºï¼ˆUBï¼‰ã€‚

> å¤±æ•ˆä¸ä»…å‘ç”Ÿåœ¨è¿­ä»£å™¨æœ¬èº«ï¼Œ**æŒ‡å‘å®¹å™¨å…ƒç´ çš„æŒ‡é’ˆå’Œå¼•ç”¨**Â ä¹Ÿå¯èƒ½ä¸€å¹¶å¤±æ•ˆã€‚

### äºŒã€å¸¸è§å®¹å™¨çš„å¤±æ•ˆè§„åˆ™ï¼ˆé€Ÿè®°ï¼‰

- **`std::vector`Â /Â `std::basic_string`ï¼ˆè¿ç»­å­˜å‚¨ï¼‰**
    
    - `push_back/insert/emplace/resize`Â **å¯èƒ½è§¦å‘æ‰©å®¹**Â â†’Â **æ‰€æœ‰**Â è¿­ä»£å™¨/æŒ‡é’ˆ/å¼•ç”¨å¤±æ•ˆ
    - å³ä¾¿ä¸æ‰©å®¹ï¼šåœ¨æ’å…¥/åˆ é™¤ä½ç½®Â **åŠå…¶ä¹‹å**Â çš„è¿­ä»£å™¨å¤±æ•ˆ
    - `erase(pos)`ï¼šä»Â `pos`Â èµ·è‡³æœ«å°¾çš„è¿­ä»£å™¨å¤±æ•ˆï¼›è¿”å›æŒ‡å‘Â **è¢«åˆ å…ƒç´ åä¸€ä¸ª**Â çš„æ–°è¿­ä»£å™¨
- **`std::deque`**
    
    - åœ¨Â **é¦–/å°¾æ’å…¥åˆ é™¤**Â å¯èƒ½ä½¿Â **å…¨éƒ¨**Â è¿­ä»£å™¨å¤±æ•ˆï¼ˆå®ç°ç›¸å…³ï¼‰
    - ä¸­é—´æ’å…¥/åˆ é™¤é€šå¸¸ä½¿Â **å—å½±å“çš„åŒºæ®µ**Â è¿­ä»£å™¨å¤±æ•ˆ
- **`std::list`Â /Â `std::forward_list`ï¼ˆé“¾å¼å­˜å‚¨ï¼‰**
    
    - **æ’å…¥/æ‹¼æ¥**Â ä¸ä¼šä½¿ç°æœ‰å…ƒç´ çš„è¿­ä»£å™¨å¤±æ•ˆ
    - **åˆ é™¤**Â ä»…ä½¿Â **è¢«åˆ å…ƒç´ **Â çš„è¿­ä»£å™¨å¤±æ•ˆ
- **`std::map`Â /Â `std::set`ï¼ˆæœ‰åºå…³è”å®¹å™¨ï¼ŒèŠ‚ç‚¹å¼ï¼‰**
    
    - `insert`Â **ä¸**Â ä½¿å·²æœ‰è¿­ä»£å™¨å¤±æ•ˆ
    - `erase`Â ä»…ä½¿Â **è¢«åˆ èŠ‚ç‚¹**Â çš„è¿­ä»£å™¨å¤±æ•ˆ
- **`std::unordered_map`Â /Â `std::unordered_set`ï¼ˆå“ˆå¸Œå®¹å™¨ï¼‰**
    
    - `rehash`Â /Â `reserve`Â å¯¼è‡´Â **æ‰€æœ‰**Â è¿­ä»£å™¨å¤±æ•ˆ
    - `insert`Â ä¸€èˆ¬ä¸ä½¿å·²æœ‰è¿­ä»£å™¨å¤±æ•ˆï¼ˆé™¤éè§¦å‘ rehashï¼‰
    - `erase`Â ä»…ä½¿è¢«åˆ å…ƒç´ çš„è¿­ä»£å™¨å¤±æ•ˆ

---

### ä¸‰ã€å…¸å‹è¸©å‘ç¤ºä¾‹

1ï¼‰è¾¹éå†è¾¹åˆ é™¤ï¼ˆ`vector`ï¼‰

```cpp
std::vector<int> v{1,2,3,4};
for (auto it = v.begin(); it != v.end(); ) {
    if (*it % 2 == 0)
        it = v.erase(it);   // ä½¿ç”¨ erase çš„è¿”å›å€¼ç»§ç»­éå†ï¼ˆæ­£ç¡®ï¼‰
    else
        ++it;               // ä¸åˆ é™¤æ—¶æ­£å¸¸å‰è¿›
}
```

2ï¼‰æ‰©å®¹å¯¼è‡´â€œå…¨å¤±æ•ˆâ€ï¼ˆ`vector`ï¼‰

```cpp
auto it = v.begin();
v.push_back(42);  // å¯èƒ½æ‰©å®¹ â†’ it å¤±æ•ˆ
// ä½¿ç”¨ it å³ UBï¼Œéœ€é‡æ–°è·å– v.begin()
```

### 3ï¼‰å“ˆå¸Œå®¹å™¨ rehash

```cpp
auto it = um.begin();
um.reserve(10000); // å¯èƒ½ rehash â†’ æ‰€æœ‰è¿­ä»£å™¨å¤±æ•ˆ
// it å¤±æ•ˆï¼Œéœ€é‡æ–°è·å–
```

### 4ï¼‰åˆ é™¤Â `list`Â å…ƒç´ çš„å®‰å…¨å†™æ³•

```cpp
for (auto it = lst.begin(); it != lst.end(); ) {
    if (need_erase(*it)) it = lst.erase(it); // ä»…åˆ å½“å‰ï¼Œå…¶ä»–è¿­ä»£å™¨ç¨³å®š
    else ++it;
}
```

### å››ã€å¦‚ä½•é¿å…è¿­ä»£å™¨å¤±æ•ˆï¼ˆå®è·µæŒ‡å—ï¼‰

1. **ä½¿ç”¨è¿”å›å€¼ç»§ç»­éå†**
    - `erase`ï¼ˆC++11 èµ·ï¼‰è¿”å›ä¸‹ä¸€ä¸ªæœ‰æ•ˆè¿­ä»£å™¨ï¼š`it = c.erase(it);`
2. **æå‰å®¹é‡è§„åˆ’**ï¼ˆè¿ç»­å­˜å‚¨å®¹å™¨ï¼‰
    - `vector/string`Â åœ¨å¤§é‡æ’å…¥å‰Â `reserve(n)`ï¼Œå‡å°‘æ‰©å®¹æ¬¡æ•°
3. **éå†æ—¶å°½é‡ä¸ç”¨ä¸‹æ ‡ + å¤–éƒ¨ç¼“å­˜è¿­ä»£å™¨**
    - ä¿®æ”¹å®¹å™¨åÂ **é‡æ–°è·å–**Â ç›¸å…³è¿­ä»£å™¨/æŒ‡é’ˆ/å¼•ç”¨
4. **é€‰æ‹©â€œèŠ‚ç‚¹ç¨³å®šâ€çš„å®¹å™¨**
    - é¢‘ç¹æ’åˆ ä¸”éœ€è¦ç¨³å®šè¿­ä»£å™¨ï¼šä¼˜å…ˆÂ `list`ã€`(unordered_)map/set`
5. **æ³¨æ„å“ˆå¸Œå®¹å™¨çš„ rehash**
    - æ‰¹é‡æ’å…¥å‰Â `reserve`ï¼›rehash åÂ **å…¨éƒ¨è¿­ä»£å™¨ä½œåºŸ**
6. **ä½¿ç”¨â€œç´¢å¼•éå†â€æ›¿ä»£â€œè¿­ä»£å™¨éå†â€**ï¼ˆå½“å®¹å™¨å…è®¸ä¸”ä½ å¯æ§åˆ¶ç´¢å¼•å¤±æ•ˆï¼‰
    - å¯¹Â `vector`Â çš„å°¾åˆ å¯ç”¨ç´¢å¼•ï¼›è­¦æƒ•æ’å…¥/åˆ é™¤å¯¼è‡´çš„å…ƒç´ ç§»åŠ¨
7. **ä¸è¦æŒæœ‰ä¸´æ—¶å®¹å™¨å…ƒç´ çš„å¼•ç”¨/è¿­ä»£å™¨**
    - è¿”å›å±€éƒ¨å®¹å™¨çš„è¿­ä»£å™¨/å¼•ç”¨ â†’ æ‚¬å‚
8. **èŒƒå›´ for + æ‹·è´å€¼**
    - å¦‚åªè¯»æ•°æ®ä¸”å®¹å™¨ä¼šå˜æ›´ç»“æ„ï¼Œè€ƒè™‘å…ˆæ‹·è´å¿…è¦çš„å€¼åˆ°ä¸´æ—¶æ•°ç»„å†å¤„ç†

### äº”ã€é¢è¯•ç”¨æ€»ç»“ï¼ˆ30 ç§’ç‰ˆï¼‰

- è¿­ä»£å™¨å¤±æ•ˆæ˜¯æŒ‡å®¹å™¨è¢«ä¿®æ”¹åï¼Œ**æ—§çš„è¿­ä»£å™¨/æŒ‡é’ˆ/å¼•ç”¨ä¸å†æœ‰æ•ˆ**ã€‚
- è¿ç»­å­˜å‚¨ï¼ˆ`vector/string`ï¼‰åœ¨Â **æ‰©å®¹æˆ–ä¸­é—´æ’å…¥/åˆ é™¤**Â ä¼šä½¿å¤§é‡è¿­ä»£å™¨å¤±æ•ˆï¼› èŠ‚ç‚¹å¼å®¹å™¨ï¼ˆ`list/map/set`ï¼‰**æ’å…¥ä¸€èˆ¬ä¸å¤±æ•ˆ**ï¼Œ`erase`Â åªä½¿è¢«åˆ å…ƒç´ å¤±æ•ˆï¼› å“ˆå¸Œå®¹å™¨åœ¨Â **rehash**Â æ—¶ä¼šä½¿Â **å…¨éƒ¨**Â è¿­ä»£å™¨å¤±æ•ˆã€‚
- è§„é¿æ–¹æ³•ï¼š**ç”¨Â `erase`Â è¿”å›å€¼ç»§ç»­éå†**ã€`reserve`Â é¢„å®¹é‡ã€ä¿®æ”¹å**é‡æ–°è·å–è¿­ä»£å™¨**ã€å¿…è¦æ—¶é€‰ç”¨Â **è¿­ä»£å™¨ç¨³å®šçš„å®¹å™¨**ã€‚

## vectorå®¹å™¨å®ç°ä¸æ‰©å……

#### 1. åº•å±‚å®ç°

**Vectoråœ¨å †ä¸­åˆ†é…äº†ä¸€æ®µè¿ç»­çš„å†…å­˜ç©ºé—´æ¥å­˜æ”¾å…ƒç´ **

**1ã€ä¸‰ä¸ªè¿­ä»£å™¨**

**ï¼ˆ1ï¼‰first ï¼š**Â æŒ‡å‘çš„æ˜¯vectorä¸­å¯¹è±¡çš„èµ·å§‹å­—èŠ‚ä½ç½®  
**ï¼ˆ2ï¼‰last ï¼š**Â æŒ‡å‘å½“å‰æœ€åä¸€ä¸ªå…ƒç´ çš„æœ«å°¾å­—èŠ‚  
**ï¼ˆ3ï¼‰end ï¼š**Â æŒ‡å‘æ•´ä¸ªvectorå®¹å™¨æ‰€å ç”¨å†…å­˜ç©ºé—´çš„æœ«å°¾å­—èŠ‚

![](https://file1.kamacoder.com/i/bagu/vectorshixianyukuorong.jpg)

**ï¼ˆ1ï¼‰last - first ï¼š**Â è¡¨ç¤º vector å®¹å™¨ä¸­ç›®å‰å·²è¢«ä½¿ç”¨çš„å†…å­˜ç©ºé—´  
**ï¼ˆ2ï¼‰end - last ï¼š**Â è¡¨ç¤º vector å®¹å™¨ç›®å‰ç©ºé—²çš„å†…å­˜ç©ºé—´  
**ï¼ˆ3ï¼‰end - first ï¼š**Â è¡¨ç¤º vector å®¹å™¨çš„å®¹é‡

#### 2. æ‰©å®¹è¿‡ç¨‹

å¦‚æœé›†åˆå·²æ»¡ï¼Œåœ¨æ–°å¢æ•°æ®çš„æ—¶å€™ï¼Œå°±è¦åˆ†é…ä¸€å—æ›´å¤§çš„å†…å­˜ï¼Œå°†åŸæ¥çš„æ•°æ®å¤åˆ¶è¿‡æ¥ï¼Œé‡Šæ”¾ä¹‹å‰çš„å†…å­˜ï¼Œåœ¨æ’å…¥æ–°å¢çš„å…ƒç´ 

æ‰€ä»¥å¯¹vectorçš„ä»»ä½•æ“ä½œï¼Œä¸€æ—¦å¼•èµ·ç©ºé—´é‡æ–°é…ç½®ï¼ŒæŒ‡å‘åŸvectorçš„æ‰€æœ‰è¿­ä»£å™¨å°±éƒ½å¤±æ•ˆäº†

**size() å’Œ capacity()**

ï¼ˆ1ï¼‰å †ä¸­åˆ†é…å†…å­˜ï¼Œå…ƒç´ è¿ç»­å­˜æ”¾ï¼Œå†…å­˜ç©ºé—´åªä¼šå¢é•¿ä¸ä¼šå‡å°‘

vectoræœ‰ä¸¤ä¸ªå‡½æ•°ï¼Œä¸€ä¸ªæ˜¯capacity()ï¼Œåœ¨ä¸åˆ†é…æ–°å†…å­˜ä¸‹æœ€å¤šå¯ä»¥ä¿å­˜çš„å…ƒç´ ä¸ªæ•°ï¼Œå¦ä¸€ä¸ªsize()ï¼Œè¿”å›å½“å‰å·²ç»å­˜å‚¨æ•°æ®çš„ä¸ªæ•°

ï¼ˆ2ï¼‰å¯¹äºvectoræ¥è¯´ï¼Œcapacityæ˜¯æ°¸è¿œå¤§äºç­‰äºsizeçš„

capacityå’Œsizeç›¸ç­‰æ—¶ï¼Œvectorå°±ä¼šæ‰©å®¹ï¼Œcapacityå˜å¤§ï¼ˆç¿»å€ï¼‰

**è¿™é‡Œæ¶‰åŠåˆ°äº†vectoræ‰©å®¹æ–¹å¼çš„é€‰æ‹©ï¼Œæ–°å¢çš„å®¹é‡é€‰æ‹©å¤šå°‘æ‰é€‚å®œå‘¢ï¼Ÿ**

**1ã€å›ºå®šæ‰©å®¹**

**æœºåˆ¶ï¼š**

æ¯æ¬¡æ‰©å®¹çš„æ—¶å€™åœ¨åŸ capacity çš„åŸºç¡€ä¸ŠåŠ ä¸Šå›ºå®šçš„å®¹é‡ï¼Œæ¯”å¦‚åˆå§‹ capacity ä¸º100ï¼Œæ‰©å®¹ä¸€æ¬¡ä¸º capacity + 20ï¼Œå†æ‰©å®¹ä»ç„¶ä¸º capacity + 20;

**ç¼ºç‚¹ï¼š**

è€ƒè™‘ä¸€ç§æç«¯çš„æƒ…å†µï¼Œvectoræ¯æ¬¡æ·»åŠ çš„å…ƒç´ æ•°é‡åˆšå¥½ç­‰äºæ¯æ¬¡æ‰©å®¹å›ºå®šå¢åŠ çš„å®¹é‡ + 1ï¼Œå°±ä¼šé€ æˆä¸€ç§æƒ…å†µï¼Œæ¯æ·»åŠ ä¸€æ¬¡å…ƒç´ å°±éœ€è¦æ‰©å®¹ä¸€æ¬¡ï¼Œè€Œæ‰©å®¹çš„æ—¶é—´èŠ±è´¹ååˆ†é«˜æ˜‚ã€‚æ‰€ä»¥å›ºå®šæ‰©å®¹å¯èƒ½ä¼šé¢ä¸´å¤šæ¬¡æ‰©å®¹çš„æƒ…å†µï¼Œæ—¶é—´å¤æ‚åº¦è¾ƒé«˜;

**ä¼˜ç‚¹ï¼š**

å›ºå®šæ‰©å®¹æ–¹å¼ç©ºé—´åˆ©ç”¨ç‡æ¯”è¾ƒé«˜ã€‚

**2ã€åŠ å€æ‰©å®¹**

**æœºåˆ¶ï¼š**

æ¯æ¬¡æ‰©å®¹çš„æ—¶å€™åŸ capacity ç¿»å€ï¼Œæ¯”å¦‚åˆå§‹capcity = 100, æ‰©å®¹ä¸€æ¬¡å˜ä¸º 200, å†æ‰©å®¹å˜ä¸º 400;

**ä¼˜ç‚¹ï¼š**

ä¸€æ¬¡æ‰©å®¹ capacity ç¿»å€çš„æ–¹å¼ä½¿å¾—æ­£å¸¸æƒ…å†µä¸‹æ·»åŠ å…ƒç´ éœ€è¦æ‰©å®¹çš„æ¬¡æ•°å¤§å¤§å‡å°‘ï¼ˆé¢„ç•™ç©ºé—´è¾ƒå¤šï¼‰ï¼Œæ—¶é—´å¤æ‚åº¦è¾ƒä½;

**ç¼ºç‚¹ï¼š**

å› ä¸ºæ¯æ¬¡æ‰©å®¹ç©ºé—´ç¿»å€ï¼Œè€Œå¾ˆå¤šç©ºé—´æ²¡æœ‰åˆ©ç”¨ä¸Šï¼Œç©ºé—´åˆ©ç”¨ç‡ä¸å¦‚å›ºå®šæ‰©å®¹ã€‚

åœ¨å®é™…åº”ç”¨ä¸­ï¼Œä¸€èˆ¬é‡‡ç”¨ç©ºé—´æ¢æ—¶é—´çš„ç­–ç•¥ã€‚

**3ã€resize()å’Œreserve()**

resize()ï¼šæ”¹å˜å½“å‰å®¹å™¨å†…å«æœ‰å…ƒç´ çš„**æ•°é‡**(size())ï¼Œè€Œä¸æ˜¯å®¹å™¨çš„å®¹é‡

1. å½“resize(len)ä¸­len>v.capacity()ï¼Œåˆ™æ•°ç»„ä¸­çš„sizeå’Œcapacityå‡è®¾ç½®ä¸ºlen;
2. å½“resize(len)ä¸­len<=v.capacity()ï¼Œåˆ™æ•°ç»„ä¸­çš„sizeè®¾ç½®ä¸ºlenï¼Œè€Œcapacityä¸å˜;

reserve()ï¼šæ”¹å˜å½“å‰å®¹å™¨çš„**æœ€å¤§å®¹é‡**ï¼ˆcapacityï¼‰

1. å¦‚æœreserve(len)çš„å€¼ > å½“å‰çš„capacity()ï¼Œé‚£ä¹ˆä¼šé‡æ–°åˆ†é…ä¸€å—èƒ½å­˜lenä¸ªå¯¹è±¡çš„ç©ºé—´ï¼Œç„¶åæŠŠä¹‹å‰çš„å¯¹è±¡é€šè¿‡copy construtorå¤åˆ¶è¿‡æ¥ï¼Œé”€æ¯ä¹‹å‰çš„å†…å­˜;
2. å½“reserve(len)ä¸­len<=å½“å‰çš„capacity()ï¼Œåˆ™æ•°ç»„ä¸­çš„capacityä¸å˜ï¼Œsizeä¸å˜ï¼Œå³ä¸å¯¹å®¹å™¨åšä»»ä½•æ”¹å˜ã€‚

#### 3. vectoræºç 

```cpp
templeta<class T,class Alloc=alloc>
class vector {
public:
    
    typedef T value_type;
    typedef value_type *pointer;
    typedef value_type &reference;
    typedef value_type *iterator;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type
    //åµŒå¥—ç±»å‹å®šä¹‰ï¼Œä¹Ÿå¯ä»¥æ˜¯å…³è”ç±»å‹å®šä¹‰
protected:
    
    typedef simple_alloc <value_type, Alloc> data_alloctor
    //ç©ºé—´é…ç½®å™¨ï¼ˆåˆ†é…å™¨ï¼‰
    iterator start;
    iterator finish;
    iterator end_of_storage;
    //è¿™3ä¸ªå°±æ˜¯vectoré‡Œçš„æ•°æ®ï¼Œæ‰€ä»¥ä¸€ä¸ªvectorå°±æ˜¯åŒ…å«3ä¸ªæŒ‡é’ˆ12byte,ä¸‹é¢æœ‰å›¾ä»‹ç»
    
    void insert_aux(iterator position, const T &x);

    //è¿™ä¸ªå°±æ˜¯vectorçš„è‡ªåŠ¨æ‰©å……å‡½æ•°ï¼Œåœ¨ä¸‹é¢ç« èŠ‚æˆ‘ä¼šæ‹¿å‡ºæ¥åˆ†æ
    void deallocate() {
        if (start)
            data_allocator::deallocate(start, end_of_storage);
    }

    //ææ„å‡½æ•°çš„éƒ¨åˆ†å®ç°å‡½æ•°

    void fill_initialize(size_type n, const T &value) {
        start = allocate_and_fill(n, value);
        finish = start + n;
        end_of_storage = finish;
    }

    //æ„é€ å‡½æ•°çš„å…·ä½“å®ç°

public:
    
    iterator begin() { return start; };
    iterator end() { return finish; };
    size_type size() const { return size_type(end() - begin()); };
    size_type capacity() const { return size_type(end_of_storage - begin()); }
    bool empty() const { return begin() == end(); }
    reference operator[](size_type n) { return *(begin() + n); };
    //é‡è½½[]è¯´æ˜vectoræ”¯æŒéšæœºè®¿é—®
    
    vector() : start(0), end(0), end_of_storage(0) {};
    
    vector(size_type n, const T &value)(fill_initialize(n, value););

    vector(long n, const T &value)(fill_initialize(n, value););

    vector(int n, const T &value)(fill_initialize(n, value););

    explicit vector(size_type n) { fill_initialize(n, T()); };

    //é‡è½½æ„é€ å‡½æ•°
    ~vector() {
        destory(start, finish);//å…¨å±€å‡½æ•°ï¼Œææ„å¯¹è±¡
        deallocate();//æˆå‘˜å‡½æ•°ï¼Œé‡Šæ”¾ç©ºé—´
    }
    //æ¥ä¸‹æ¥å°±æ˜¯ä¸€äº›åŠŸèƒ½å‡½æ•°
    reference front() { return *begin(); };
    reference back() { return *(end() - 1); };
    void push_back(const T &x) {
        if (finsih != end_of_storage) {
            construct(finish, x);
            ++finish;
        } else insert_aux(end(), x);
        //å…ˆæ‰©å……åœ¨æ·»åŠ 
    }

    void pop_back() {
        --finish;
        destory(finish);
    }

    iterator erase(iterator position) {
        if (position + 1 != end())
            copy(position + 1, finish, position);
        --finish;
        destory(finish);
        return position;
    }

    void resize(size_type new_size, const T &x) {
        if (new_size() < size())
            erase(begin() + new_size, end());
        else
            insert(end(), new_size - size(),x);
    }

    void resize()(size_type new_size) { resize(new_size, T()); }
    void clear() { erase(begin(), end()); }
    
protected:
    //é…ç½®ç©ºé—´å¹¶å¡«æ»¡å†…å®¹
    iterator allocate_and_fill(size_type n, const T &x) {
        iterator result = data_allocator::allocate(n);
        uninitialized_fill_n(result, n, x);//å…¨å±€å‡½æ•°
    }
}
```

vectorè¿­ä»£å™¨ï¼šç”±äºvectorç»´æŠ¤çš„æ˜¯ä¸€ä¸ªçº¿æ€§åŒºé—´ï¼Œæ‰€ä»¥æ™®é€šæŒ‡é’ˆå…·å¤‡ä½œä¸ºvectorè¿­ä»£å™¨çš„æ‰€æœ‰æ¡ä»¶ï¼Œå°±ä¸éœ€è¦é‡è½½operator+ï¼Œoperator*ä¹‹ç±»çš„ä¸œè¥¿

```cpp
template <class T, class Alloc = alloc>
class vector {
public:
    typedef T value_type;
    typedef value_type* iterator; //vectorçš„è¿­ä»£å™¨æ˜¯åŸç”ŸæŒ‡é’ˆ
    // ...
};
```

vectorçš„æ•°æ®ç»“æ„ï¼šçº¿æ€§ç©ºé—´ã€‚ä¸ºäº†é™ä½é…ç½®ç©ºé—´çš„æˆæœ¬ï¼Œæˆ‘ä»¬å¿…é¡»è®©å…¶å®¹é‡å¤§äºå…¶å¤§å°ã€‚

vectorçš„æ„é€ ä»¥åŠå†…å­˜ç®¡ç†ï¼šå½“æˆ‘ä»¬ä½¿ç”¨push_backæ’å…¥å…ƒç´ åœ¨å°¾ç«¯çš„æ—¶å€™ï¼Œæˆ‘ä»¬é¦–å…ˆæ£€æŸ¥æ˜¯å¦è¿˜æœ‰å¤‡ç”¨ç©ºé—´ä¹Ÿå°±æ˜¯è¯´endæ˜¯å¦ç­‰äºend_of_storageï¼Œå¦‚æœæœ‰ç›´æ¥æ’å…¥ï¼Œå¦‚æœæ²¡æœ‰å°±æ‰©å……ç©ºé—´

```cpp
template<class T, class Alloc>
void vector<T, Alloc>::insert_aux(iterator position, const T &x) {
    if (finish != end_of_storage) {//æœ‰å¤‡ç”¨ç©ºé—´
        consruct(finish, *(finish - 1));//åœ¨å¤‡ç”¨ç©ºé—´å¤„æ„é€ ä¸€ä¸ªå…ƒç´ ï¼Œä»¥vectoræœ€åä¸€ä¸ªå…ƒç´ ä¸ºå…¶åˆå€¼
        ++finish;
        T x_copy = x;
        copy_backward(position, finish - 2, finish - 1);
        *position = x_copy;
    } else {
        const size_type old_size = size();
        const size_type len = old_size != 0 ? 2 * old_size() : 1;
        //vectorä¸­å¦‚æœæ²¡æœ‰å…ƒç´ å°±é…ç½®ä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æœæœ‰å°±é…ç½®2å€å…ƒç´ ã€‚
        iterator new_start = data_allocator::allocate(len);
        iterator new_finish = new_start;
        try {
            //æ‹·è´æ’å…¥ç‚¹ä¹‹å‰çš„å…ƒç´ 
            new_finish = uninitialized_copy(start, position, new_start);
            construct(new_finish, x);
            ++new_finish;
            //æ‹·è´æ’å…¥ç‚¹ä¹‹åçš„å…ƒç´ 
            new_finish = uninitialized_copy(position, finish, new_finish);
        }
        catch () {
            destroy(new_start, new_finish);
            data_allocator::deallocate(new_start, len);
            throw;
        }
        //ææ„å¹¶é‡Šæ”¾åŸvector
        destory(begin(), end());
        deallocate();
        //è°ƒæ•´è¿­ä»£å™¨æŒ‡å‘æ–°çš„vector
        start = new_start;
        finish = new_finish;
        end_of_storage = new_start + len;
    }
}
```

æ•´ä¸ªåˆ†ä¸º3ä¸ªéƒ¨åˆ†ï¼Œé…ç½®æ–°ç©ºé—´ï¼Œè½¬ç§»å…ƒç´ ï¼Œé‡Šæ”¾åŸæ¥çš„å…ƒç´ ä¸ç©ºé—´,å› æ­¤ä¸€æ—¦å¼•èµ·ç©ºé—´é…ç½®æŒ‡å‘ä»¥å‰vectorçš„æ‰€æœ‰è¿­ä»£å™¨éƒ½è¦å¤±æ•ˆã€‚

![](https://file1.kamacoder.com/i/bagu/_vector_yuanma_yangwang_01.png)

vectorçš„éƒ¨åˆ†å…ƒç´ æ“ä½œï¼špop_back,erase,clear,insert

```cpp
void pop_back() {
    --finish;
    destory(finish);
}

//eraseç‰ˆæœ¬ä¸€ï¼šæ¸…é™¤èŒƒå›´å…ƒç´ 

iterator erase(iterator first, iterator last) {
    interator i = copy(last, finish, first);
    destory(i, finish);
    finish = finish - (last - first);
    return first;
}

//ç‰ˆæœ¬äºŒï¼šæ¸…é™¤æŸä¸ªä½ç½®ä¸Šçš„å…ƒç´ 
iterator erase(iterator position) {
    if (position + 1 != finish) {
        copy(position + 1, finish, position);
        --finish;
        distory(finish);
        return position;
    }
}

void clear() { erase(begin(), end()) };
template<class T, class Alloc>
void vector<T, Alloc>::insert(iterator position, size_type n, const T &x) {
    if (n != 0) {
        if (size_type(end_of_strage - finish) > n) {
            //å¤‡ç”¨ç©ºé—´å¤§äºæ’å…¥çš„å…ƒç´ æ•°é‡
            T x_copy = x;
            //ä»¥ä¸‹è®¡ç®—æ’å…¥ç‚¹ä¹‹åçš„ç°æœ‰å…ƒç´ ä¸ªæ•°
            const size_type elems_after = finish - positon;
            iterator old_finish = finish;
            if (elems_after > n) {
                //æ’å…¥ç‚¹ä¹‹åçš„å…ƒç´ ä¸ªæ•°å¤§äºè¦æ’å…¥çš„å…ƒç´ ä¸ªæ•°
                uninitialiazed_copy(finish - n, finish, finish);
                finish += n;//å°†vectorçš„å°¾ç«¯æ ‡è®°åç§»
                copy_backward(position, old_finish - n, old_finish);
                fill(position, old_finish, x_copy);//ä»æ’å…¥ç‚¹ä¹‹åå¼€å§‹æ’å…¥æ–°å€¼
            } else {
                //æ’å…¥ç‚¹ä¹‹åçš„å…ƒç´ ä¸ªæ•°å°äºè¦æ’å…¥çš„å…ƒç´ ä¸ªæ•°
                uninitialiazed_fill_n(finish, n - elems_after, finish);
                finish += n - elems_after;
                uninitialiazed_copy(position, old_finish, finish);
                finish += elems_after;
                fill(position, old_finish, x_copy);
            }
            else {
                //å¤‡ç”¨ç©ºé—´å°äºè¦æ’å…¥å…ƒç´ çš„ä¸ªæ•°
                //é¦–å…ˆå†³å®šæ–°é•¿åº¦ï¼ŒåŸé•¿åº¦çš„ä¸¤å€ï¼Œæˆ–è€…è€é•¿åº¦+æ–°çš„å…ƒç´ ä¸ªæ•°
                const size_type old_size = size();
                const size_type len = old_size + max(old_size, n);
                //ä»¥ä¸‹é…ç½®æ–°çš„ç©ºé—´
                iterator new_start = data_allocator::allocate(len);
                iterator new_finish = new_start;
                _STL_TRY {
                    //æ‹·è´æ’å…¥ç‚¹ä¹‹å‰çš„å…ƒç´ 
                    new_finish = uninitialized_copy(start, position, new_start);
                    //æŠŠæ–°å¢å…ƒç´ ï¼ˆåˆå€¼çš†ä¸ºn)ä¼ å…¥æ–°ç©ºé—´
                    new_finish=uninitialized_fill_n
                    //æ‹·è´æ’å…¥ç‚¹ä¹‹åçš„å…ƒç´ 
                    new_finish=uninitialized_copy(position, finish, new_finish);
                    //è¿™ä¸€æ®µæœ‰åˆ©äºç†è§£ä¸Šé¢çš„insert_auxå‡½æ•°
                }

#ifdef _STL_USE_EXCEPTIONS
                catch(){
                    //å¦‚æœæœ‰å¼‚å¸¸å‘ç”Ÿ
                    destroy(new_start,new_finish);
                    data_allocator::deallocate(new_start,len);
                    throw;
                }
#endif/* _STL_USE_EXCEPTIONS*/
                //ææ„å¹¶é‡Šæ”¾åŸvector
                destory(begin(), end());
                deallocate();
                //è°ƒæ•´è¿­ä»£å™¨æŒ‡å‘æ–°çš„vector
                start = new_start;
                finish = new_finish;
                end_of_storage = new_start + len;
            }
        }
    }
}
```

### listï¼ˆé“¾è¡¨ï¼‰

#### listè®¾è®¡

æ¯ä¸ªå…ƒç´ éƒ½æ˜¯æ”¾åœ¨ä¸€å—å†…å­˜ä¸­ï¼Œä»–çš„å†…å­˜ç©ºé—´å¯ä»¥æ˜¯ä¸è¿ç»­çš„ï¼Œé€šè¿‡æŒ‡é’ˆæ¥è¿›è¡Œæ•°æ®çš„è®¿é—®

åœ¨å“ªé‡Œæ·»åŠ åˆ é™¤å…ƒç´ æ€§èƒ½éƒ½å¾ˆé«˜ï¼Œä¸éœ€è¦ç§»åŠ¨å†…å­˜ï¼Œå½“ç„¶ä¹Ÿä¸éœ€è¦å¯¹æ¯ä¸ªå…ƒç´ éƒ½è¿›è¡Œæ„é€ ä¸ææ„äº†ï¼Œæ‰€ä»¥å¸¸ç”¨æ¥åšéšæœºæ’å…¥å’Œåˆ é™¤æ“ä½œå®¹å™¨

listå±äºåŒå‘é“¾è¡¨ï¼Œå…¶ç»“ç‚¹ä¸listæœ¬èº«æ˜¯åˆ†å¼€è®¾è®¡çš„ï¼š

```cpp
template<class T, class Alloc = alloc>
class list {
protected:
    typedef listnode <T> listnode;
public:
    typedef listnode link_type;
    typedef listiterator<T, T &, T> iterator;
protected:
    link_type node;
};
```

å­¦ä¹ åˆ°äº†ä¸€ä¸ªåˆ†ææ–¹æ³•ï¼Œæ‹¿åˆ°è¿™æ ·ä¸€ä¸ªç±»ï¼Œå…ˆçœ‹å®ƒçš„æ•°æ®æ¯”å¦‚ä¸Šé¢çš„linktype nodeï¼Œç„¶åæˆ‘ä»¬å†çœ‹å®ƒçš„å‰ç¼€ï¼Œlinktypeï¼Œå»ä¸Šé¢åœ¨linktype,æ‰¾åˆ°typedef listnode linktype;æŒ‰è¿™ä¸ªæ–¹æ³•ç»§ç»­æ‰¾åˆ°ä¸Šé¢çš„typedef listnodeÂ listnode;æˆ‘ä»¬å‘ç°list_nodeæ˜¯ä¸‹é¢çš„ç±»ï¼Œæˆ‘ä»¬ä¸€å±‚å±‚çš„å¯»æ‰¾ï¼Œå°±èƒ½çœ‹æ‡‚è¿™äº›æºç 

```cpp
template<class T>
struct _listnode {
    typedef void voidpointer;
    void_pointer prev;
    void_pointer next;
    T data;
};
```

listæ˜¯ä¸€ä¸ªç¯çŠ¶çš„åŒå‘é“¾è¡¨ï¼ŒåŒæ—¶å®ƒä¹Ÿæ»¡è¶³STLå¯¹äºâ€œå‰é—­åå¼€â€çš„åŸåˆ™ï¼Œå³åœ¨é“¾è¡¨å°¾ç«¯å¯ä»¥åŠ ä¸Šç©ºç™½èŠ‚ç‚¹

listçš„è¿­ä»£å™¨çš„è®¾è®¡ï¼š

è¿­ä»£å™¨æ˜¯æ³›åŒ–çš„æŒ‡é’ˆæ‰€ä»¥é‡Œé¢é‡è½½äº†->ï¼Œ--ï¼Œ++ï¼Œ*ï¼ˆï¼‰ï¼Œç­‰è¿ç®—ç¬¦ï¼ŒåŒæ—¶è¿­ä»£å™¨æ˜¯ç®—æ³•ä¸å®¹å™¨ä¹‹é—´çš„æ¡¥æ¢ï¼Œç®—æ³•éœ€è¦äº†è§£å®¹å™¨çš„æ–¹æ–¹é¢é¢ï¼Œäºæ˜¯å°±è¯ç”Ÿäº†5ç§å…³è”ç±»å‹ï¼Œ(è¿™5ç§ç±»å‹æ˜¯å¿…å¤‡çš„ï¼Œå¯èƒ½è¿˜éœ€è¦å…¶ä»–ç±»å‹)æˆ‘ä»¬çŸ¥é“ç®—æ³•ä¼ å…¥çš„æ˜¯è¿­ä»£å™¨æˆ–è€…æŒ‡é’ˆï¼Œç®—æ³•æ ¹æ®ä¼ å…¥çš„è¿­ä»£å™¨æˆ–æŒ‡é’ˆæ¨æ–­å‡ºç®—æ³•æ‰€æƒ³è¦äº†è§£çš„å®¹å™¨é‡Œçš„5ç§å…³è”ç±»å‹çš„ç›¸å…³ä¿¡æ¯ã€‚ç”±äºå…‰ä¼ å…¥æŒ‡é’ˆï¼Œç®—æ³•æ¨æ–­ä¸å‡ºæ¥å…¶æƒ³è¦çš„ä¿¡æ¯ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ä¸ªä¸­é—´å•†ï¼ˆèƒå–å™¨ï¼‰ä¹Ÿå°±æ˜¯æˆ‘ä»¬æ‰€è¯´çš„iterator traitsç±»ï¼Œå¯¹äºä¸€èˆ¬çš„è¿­ä»£å™¨ï¼Œå®ƒç›´æ¥æä¾›è¿­ä»£å™¨é‡Œçš„å…³è”ç±»å‹å€¼ï¼Œè€Œå¯¹äºæŒ‡é’ˆå’Œå¸¸é‡æŒ‡é’ˆï¼Œå®ƒé‡‡ç”¨çš„ç±»æ¨¡æ¿åç‰¹åŒ–ï¼Œä»è€Œæä¾›å…¶æ‰€éœ€è¦çš„å…³è”ç±»å‹çš„å€¼ã€‚

![](https://file1.kamacoder.com/i/bagu/_stl_list_yangwang_02.png)

```cpp
// é’ˆå¯¹ä¸€èˆ¬çš„è¿­ä»£å™¨ç±»å‹,ç›´æ¥å–è¿­ä»£å™¨å†…å®šä¹‰çš„å…³è”ç±»å‹
template<class I>
struct iterator_traits {
    typedef typename I::iteratorcategory iteratorcategory;
    typedef typename I::valuetype valuetype;
    typedef typename I::differencetype differencetype;
    typedef typename I::pointer pointer;
    typedef typename I::reference reference;
};
â€‹// é’ˆå¯¹æŒ‡é’ˆç±»å‹è¿›è¡Œç‰¹åŒ–,æŒ‡å®šå…³è”ç±»å‹çš„å€¼
template<class T>
struct iteratortraits<T> {
    typedef randomaccessiteratortag iteratorcategory;
    typedef T value_type;
    typedef ptrdifft differencetype;
    typedef T *pointer;
    typedef T &reference;
};
// é’ˆå¯¹æŒ‡é’ˆå¸¸é‡ç±»å‹è¿›è¡Œç‰¹åŒ–,æŒ‡å®šå…³è”ç±»å‹çš„å€¼
template<class T>
struct iteratortraits<const T> {
    typedef randomaccessiteratortag iteratorcategory;
    typedef T valuetype;  // valuetyeè¢«ç”¨äºåˆ›å»ºå˜é‡,ä¸ºçµæ´»èµ·è§,å– T è€Œé const T ä½œä¸º value_type
    typedef ptrdifft differencetype;
    typedef const T *pointer;
    typedef const T &reference;
};
```

#### vectorå’Œlistçš„åŒºåˆ«

1. vectoråº•å±‚å®ç°æ˜¯æ•°ç»„ï¼›listæ˜¯åŒå‘é“¾è¡¨
2. vectoræ˜¯é¡ºåºå†…å­˜,æ”¯æŒéšæœºè®¿é—®ï¼Œlistä¸è¡Œ
3. vectoråœ¨ä¸­é—´èŠ‚ç‚¹è¿›è¡Œæ’å…¥åˆ é™¤ä¼šå¯¼è‡´å†…å­˜æ‹·è´ï¼Œlistä¸ä¼š
4. vectorä¸€æ¬¡æ€§åˆ†é…å¥½å†…å­˜ï¼Œä¸å¤Ÿæ—¶æ‰è¿›è¡Œç¿»å€æ‰©å®¹ï¼›listæ¯æ¬¡æ’å…¥æ–°èŠ‚ç‚¹éƒ½ä¼šè¿›è¡Œå†…å­˜ç”³è¯·
5. vectoréšæœºè®¿é—®æ€§èƒ½å¥½ï¼Œæ’å…¥åˆ é™¤æ€§èƒ½å·®ï¼›listéšæœºè®¿é—®æ€§èƒ½å·®ï¼Œæ’å…¥åˆ é™¤æ€§èƒ½å¥½

### dequeï¼ˆåŒç«¯æ•°ç»„ï¼‰

æ”¯æŒå¿«é€Ÿéšæœºè®¿é—®ï¼Œç”±äºdequeéœ€è¦å¤„ç†å†…éƒ¨è·³è½¬ï¼Œå› æ­¤é€Ÿåº¦ä¸Šæ²¡æœ‰vectorå¿«ã€‚

**1ã€dequeæ¦‚è¿°ï¼š**

dequeæ˜¯ä¸€ä¸ªåŒç«¯å¼€å£çš„è¿ç»­çº¿æ€§ç©ºé—´ï¼Œå…¶å†…éƒ¨ä¸ºåˆ†æ®µè¿ç»­çš„ç©ºé—´ç»„æˆï¼Œéšæ—¶å¯ä»¥å¢åŠ ä¸€æ®µæ–°çš„ç©ºé—´å¹¶é“¾æ¥

**æ³¨æ„:**

ç”±äºdequeçš„è¿­ä»£å™¨æ¯”vectorè¦å¤æ‚ï¼Œè¿™å½±å“äº†å„ä¸ªè¿ç®—å±‚é¢ï¼Œæ‰€ä»¥é™¤éå¿…è¦å°½é‡ä½¿ç”¨vectorï¼›ä¸ºäº†æé«˜æ•ˆç‡ï¼Œåœ¨å¯¹dequeè¿›è¡Œæ’åºæ“ä½œçš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆæŠŠdequeå¤åˆ¶åˆ°vectorä¸­å†è¿›è¡Œæ’åºæœ€ååœ¨å¤åˆ¶å›deque

**2ã€dequeä¸­æ§å™¨ï¼š**

dequeæ˜¯ç”±ä¸€æ®µä¸€æ®µçš„å®šé‡è¿ç»­ç©ºé—´æ„æˆã€‚ä¸€æ—¦æœ‰å¿…è¦åœ¨å…¶å¤´ç«¯æˆ–è€…å°¾ç«¯å¢åŠ æ–°çš„ç©ºé—´ï¼Œä¾¿é…ç½®ä¸€æ®µå®šé‡è¿ç»­ç©ºé—´ï¼Œä¸²æ¥åœ¨æ•´ä¸ªdequeçš„å¤´ç«¯æˆ–è€…å°¾ç«¯

**å¥½å¤„ï¼š**

é¿å…â€œvectorçš„é‡æ–°é…ç½®ï¼Œå¤åˆ¶ï¼Œé‡Šæ”¾â€çš„è½®å›ï¼Œç»´æŠ¤è¿æ•´ä½“è¿ç»­çš„å‡è±¡ï¼Œå¹¶æä¾›éšæœºè®¿é—®çš„æ¥å£ï¼›

**åå¤„ï¼š**

å…¶è¿­ä»£å™¨å˜å¾—å¾ˆå¤æ‚

![](https://file1.kamacoder.com/i/bagu/_deque_yuanma_yangwang_01.png)

dequeé‡‡ç”¨ä¸€å—mapä½œä¸ºä¸»æ§ï¼Œå…¶ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½æ˜¯æŒ‡é’ˆï¼ŒæŒ‡å‘å¦ä¸€ç‰‡è¿ç»­çº¿æ€§ç©ºé—´ï¼Œç§°ä¹‹ä¸ºç¼“å­˜åŒºï¼Œè¿™ä¸ªåŒºæ‰æ˜¯ç”¨æ¥å‚¨å­˜æ•°æ®çš„ã€‚

```cpp
template<class T, class Alloc=alloc, size_t Bufsize = 0>
class deque {

public:

    typedef T value_type;
    typedef value_type pointer*;
    typedef size_t size_type;
    // ...

public:

    typedef _deque_iterator<T, T &, T *, BufSiz> iterator;

protected:

    typedef pointer *map_pointer;

protected:

    iterator start;
    iterator finish;
    map_pointer map;//æŒ‡å‘map
    size_type map_size;//mapå†…å¯å®¹çº³å¤šå°‘æŒ‡é’ˆ
}

//mapå…¶å®æ˜¯ä¸€ä¸ªT**
```

dequeè¿­ä»£å™¨:

```cpp
template<class T, class Ref, class Ptr, size_t BufSiz>

struct _deque_iterator {
    typedef _deque_iterator<T, T &, T *, BufSiz> iterator;
    typedef _deque_iterator<T, cosnt T &, const T *, BufSiz> const_iterator;
    static size_t buffer_size() { return _deque_buf_size(BufSiz, sizeof(T)); };
    typedef randem_access_iterator_tag iterator_category;
    typedef T value_type;
    typedef Ptr pointer;
    typedef Ref reference;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T **map_pointer;
    typedef _deque_iterator self;
    T *cur;
    T *first;
    T *last;
    map_pointer node;
    // ...
    //è¿™æ˜¯ä¸€ä¸ªå†³å®šç¼“å­˜åŒºå¤§å°çš„å‡½æ•°
    inline size_t _deque_buf_size(size_t n, size_t sz) {
        return n != 0 ? n :
        (sz < 512 ? size_t(512 / sz) : size_t(1));
    }
}
```

dequeæ‹¥æœ‰ä¸¤ä¸ªæ•°æ®æˆå‘˜

startä¸finishè¿­ä»£å™¨ï¼Œåˆ†åˆ«ç”±deque:begin()ä¸deque:end()ä¼ å›

```cpp
//è¿­ä»£å™¨çš„å…³é”®è¡Œä¸ºï¼Œå…¶ä¸­è¦æ³¨æ„çš„æ˜¯ä¸€æ—¦é‡åˆ°ç¼“å†²åŒºè¾¹ç¼˜ï¼Œå¯èƒ½éœ€è¦è·³ä¸€ä¸ªç¼“å­˜åŒº

void set_node(map_pointer new_node) {
    node = new_node;
    first = *new_node;
    last = first + difference_type(buffer_size());
}

//æ¥ä¸‹æ¥é‡è½½è¿ç®—å­æ˜¯_deque_iterator<>æˆåŠŸè¿ä½œçš„å…³é”®
reference operator*() const { return *cur; }

pointer operator->() const { return &(operator*()); }

difference_type operatorâ€” (const self &x) const {
    return difference_type (buffer_szie()) * (node-x.node-1)+(cur-first)+(x.last-x.cur);
}

self &operator++() {
    ++cur;
    if (cur == last) {
        set_node(node + 1);
        cur = first;
    }
    return *this;
}

self operator++(int) {
    self temp = *this;
    ++*this;
    return temp;
}

self &operator--() {
    if (cur == first) {
        set_node(node - 1);
        cur = last;
    }
    --cur;
    return *this;
}

self operator-(int) {
    self temp = *this;
    --*this;
    return temp;
}

//ä»¥ä¸‹å®ç°éšæœºå­˜å–ï¼Œè¿­ä»£å™¨å¯ä»¥ç›´æ¥è·³è·ƒnä¸ªè·ç¦»
self &operator+=(difference_type n) {
    difference_type offest = n + (cur - first);
    if (offest > 0 && offest < difference_type(buffer_size()))
        cur += n;
    else {
        offest > 0 ? offest / fifference_type(buffer_size()) : -difference_type((-offest - 1) / buffer_size()) - 1;
        set_node(node + node_offest);
        cur = first + (offest - node_offest * difference_type(buffer_size()));
    }
    return *this;
}

self operator+(differnece_type n) {
    self tmp = *this;
    return tmp += n;
}

self operator-=() { return *this += -n; }

self operator-(difference_type n) {
    self temp = *this;
    return *this -= n;
}

rference operator[](difference_type n) {
    return *(*this + n);
}

bool operator==(const self &x) const { return cur == x.cur; }
bool operator!=(const self &x) const { return !(*this == x); }
bool operatoe<(const self &x) const {
    return (node == x.node) ? (cur < x.cur) : (node - x.node);
}
```

**dequeæ•°æ®ç»“æ„:**

dequeé™¤äº†ç»´æŠ¤ä¸€ä¸ªmapæŒ‡é’ˆä»¥å¤–ï¼Œè¿˜ç»´æŠ¤äº†startä¸finishè¿­ä»£å™¨åˆ†åˆ«æŒ‡å‘ç¬¬ä¸€ç¼“å†²åŒºçš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œå’Œæœ€åä¸€ä¸ªç¼“å†²åŒºçš„æœ€åä¸€ä¸ªå…ƒç´ çš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼ŒåŒæ—¶å®ƒè¿˜å¿…é¡»è®°ä½å½“å‰mapçš„å¤§å°ã€‚å…·ä½“ç»“æ„å’Œæºä»£ç çœ‹ä¸Šé¢

**dequeçš„æ„é€ ä¸ç®¡ç†**

```cpp
//dequeé¦–å…ˆè‡ªè¡Œå®šä¹‰äº†ä¸¤ä¸ªç©ºé—´é…ç½®å™¨
typedef simple_alloc <value_type, Alloc> data_allocator;
typedef simple_alloc <pointer, Alloc> map_allocator;
```

dequeä¸­æœ‰ä¸€ä¸ªæ„é€ å‡½æ•°ç”¨äºæ„é€ dequeç»“æ„å¹¶èµ‹åˆå€¼

```cpp
deque(int n, const value_type &value) : start(), finish(), map(0), map_size(0) {
    fill_initialize(n, value);//è¿™ä¸ªå‡½æ•°å°±æ˜¯ç”¨æ¥æ„å»ºdequeç»“æ„ï¼Œå¹¶è®¾ç«‹åˆå€¼
}

template<class T, class Alloc, size_t BufSize)
void deque<T, Alloc, BufSize>::fill_initialize(size_type n, const value_type &value) {
    creat_map_and_node(n);//å®‰æ’ç»“æ„
    map_pointer cur;
    _STL_TRY {
        //ä¸ºæ¯ä¸ªç¼“å­˜åŒºèµ‹å€¼
        for (cur=start.node;cur<finish.node;++cur)
        uninitalized_ fill(*cur, *cur+buffer_size(), value);
        //è®¾ç½®æœ€åä¸€ä¸ªèŠ‚ç‚¹æœ‰ä¸€ç‚¹ä¸åŒ
        uninitalized_fill(finish.first, finish.cur, value);
    }

    catch() {
        // ...
    }
}

template<class T, class Alloc, size_t Bufsize>
void deque<T, alloc, Bufsize>::creat_map_and_node(size_type num_elements) {
    //éœ€è¦èŠ‚ç‚¹æ•°=å…ƒç´ ä¸ªæ•°/æ¯ä¸ªç¼“å­˜åŒºçš„å¯å®¹çº³å…ƒç´ ä¸ªæ•°+1
    size_type num_nodes = num_elements / Buf_size() + 1;
    map_size = max(initial_map_size(), num_nodes + 2);//å‰åé¢„ç•™2ä¸ªä¾›æ‰©å……
    
    //åˆ›å»ºä¸€ä¸ªå¤§å°ä¸ºmap_sizeçš„map
    map = map_allocator::allocate(map_size);
    
    //åˆ›å»ºä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘mapæ‰€æ‹¥æœ‰çš„å…¨éƒ¨èŠ‚ç‚¹çš„æœ€ä¸­é—´åŒºæ®µ
    map_pointer nstart = map + (map_size() - num_nodes) / 2;
    map_poniter nfinish = nstart + num_nodes - 1;
    map_pointer cur;
    
    _STL_TRY {
        //ä¸ºæ¯ä¸ªèŠ‚ç‚¹é…ç½®ç¼“å­˜åŒº
        for (cur=nstart;cur<nfinish;++cur)
        +cur=allocate_node();
    }
    catch() {
        // ...
    }

    //æœ€åä¸ºdequeå†…çš„startå’Œfinishè®¾å®šå†…å®¹
    start.set_node(nstart);
    finish.set_node(nfinish);
    start.cur = start.first;
    finish.cur = finish.first + num_elements % buffer_szie();
}
```

æ¥ä¸‹æ¥å°±æ˜¯æ’å…¥æ“ä½œçš„å®ç°ï¼Œç¬¬ä¸€ï¼Œé¦–å…ˆåˆ¤æ–­æ˜¯å¦æœ‰æ‰©å……mapçš„éœ€æ±‚ï¼Œè‹¥æœ‰å°±æ‰©ï¼Œç„¶åå°±æ˜¯åœ¨æ’å…¥å‡½æ•°ä¸­ï¼Œé¦–å…ˆåˆ¤æ–­æ˜¯å¦åœ¨ç»“å°¾æˆ–è€…å¼€å¤´ä»è€Œåˆ¤æ–­æ˜¯å¦è·³è·ƒèŠ‚ç‚¹ã€‚

```cpp
void push_back(const value_type &t) {
    if (finish.cur != finish.last - 1) {
        construct(finish.cur, t);
        ++finish.cur;
    } else
        push_back_aux(t);
}

// ç”±äºå°¾ç«¯åªå‰©ä¸€ä¸ªå¯ç”¨å…ƒç´ ç©ºé—´ï¼ˆfinish.cur=finish.last-1ï¼‰ï¼Œ
// æ‰€ä»¥æˆ‘ä»¬å¿…é¡»é‡æ–°é…ç½®ä¸€ä¸ªç¼“å­˜åŒºï¼Œåœ¨è®¾ç½®æ–°å…ƒç´ çš„å†…å®¹ï¼Œç„¶åæ›´æ”¹è¿­ä»£å™¨çš„çŠ¶æ€

tempalate<class T, class Alloc, size_t BufSize>
void deque<T, alloc, BufSize>::push_back_aux(const value_type &t) {
    value_type t_copy = t;
    reserve_map_at_back();
    *(finish.node + 1) = allocate_node();
    _STL_TRY {
        construct(finish.cur, t_copy);
        finish.set_node(finish.node+1);
        finish.cur=finish.first;
    }
    - STL_UNWIND {
        deallocate_node(*(finish.node + 1));
    }
}
//push_frontä¹Ÿæ˜¯ä¸€æ ·çš„é€»è¾‘
```

| deque | vector                                                  |                                    |
| ----- | ------------------------------------------------------- | ---------------------------------- |
| ç»„ç»‡æ–¹å¼  | æŒ‰é¡µæˆ–å—æ¥åˆ†é…å­˜å‚¨å™¨çš„ï¼Œæ¯é¡µåŒ…å«å›ºå®šæ•°ç›®çš„å…ƒç´                                  | åˆ†é…ä¸€æ®µè¿ç»­çš„å†…å­˜æ¥å­˜å‚¨å†…å®¹                     |
| æ•ˆç‡    | å³ä½¿åœ¨å®¹å™¨çš„å‰ç«¯ä¹Ÿå¯ä»¥æä¾›å¸¸æ•°æ—¶é—´çš„insertå’Œeraseæ“ä½œï¼Œè€Œä¸”åœ¨ä½“ç§¯å¢é•¿æ–¹é¢ä¹Ÿæ¯”vectoræ›´å…·æœ‰æ•ˆç‡ | åªæ˜¯åœ¨åºåˆ—çš„å°¾ç«¯æ’å…¥å…ƒç´ æ—¶æ‰æœ‰æ•ˆç‡ï¼Œä½†æ˜¯éšæœºè®¿é—®é€Ÿåº¦è¦æ¯”dequeå¿« |

### stack && queue

æ¦‚è¿°ï¼šæ ˆä¸é˜Ÿåˆ—è¢«ç§°ä¹‹ä¸ºduqueçš„é…æ¥å™¨ï¼Œå…¶åº•å±‚æ˜¯ä»¥dequeä¸ºåº•éƒ¨æ¶æ„ã€‚é€šè¿‡dequeæ‰§è¡Œå…·ä½“æ“ä½œ

![](https://file1.kamacoder.com/i/bagu/_stack_yuanma_yangwang_01.png)

#### æºç 

```cpp
template<class T, class Sequence=deque <T>>

class stack {//_STL_NULL_TMPL_ARGSå±•å¼€ä¸º<>
    friend bool operator==
    _STL_NULL_TMPL_ARGS(const stack &, const stack &);
    friend bool operator<
    _STL_NULL_TMPL_ARGS(coonst
    stack&,const stack&);

public:
    
    typedef typename Sequence::value_type value_type;
    typedef typename Sequence::size_type size_type;
    typedef typename Sequence::reference reference;
    typedef typename Sequence::const_reference const_refernece;

protected:
    
    Sequence c;

public:
    
    bool empty() const { return c.empty(); }
    size_type size() const { return c.size(); }
    reference top() {
        return c.back();
    }
    const_rference top() const { return c.back(); }
    void push(const value_type &x) { c.push_back(x); }
    void pop_back() { c.pop_back(); }
};

template<class T, class Sequence>
bool operator==(const stack<T, Sequence> &x, const stack<T, Sequence> &y) {
    return x.c == y.c;
}

template<class T, class Sequence>
bool operator<(const stack<T, Sequence> &x, const stack<T, Sequence> &y) {
    return x.c < y.c;
}
```

### heap && priority_queue

**heapï¼ˆå †ï¼‰**ï¼š

å»ºç«‹åœ¨å®Œå…¨äºŒå‰æ ‘ä¸Šï¼Œåˆ†ä¸ºä¸¤ç§ï¼Œå¤§æ ¹å †ï¼Œå°æ ¹å †,å…¶åœ¨STLä¸­åšpriority_queueçš„åŠ©æ‰‹ï¼Œå³ï¼Œä»¥ä»»ä½•é¡ºåºå°†å…ƒç´ æ¨å…¥å®¹å™¨ä¸­ï¼Œç„¶åå–å‡ºæ—¶ä¸€å®šæ˜¯ä»ä¼˜å…ˆæƒæœ€é«˜çš„å…ƒç´ å¼€å§‹å–ï¼Œå®Œå…¨äºŒå‰æ ‘å…·æœ‰è¿™æ ·çš„æ€§è´¨ï¼Œé€‚åˆåšpriority_queueçš„åº•å±‚

**priority_queue:**

**ä¼˜å…ˆé˜Ÿåˆ—**ï¼Œä¹Ÿæ˜¯é…æ¥å™¨ã€‚å…¶å†…çš„å…ƒç´ ä¸æ˜¯æŒ‰ç…§è¢«æ¨å…¥çš„é¡ºåºæ’åˆ—ï¼Œè€Œæ˜¯è‡ªåŠ¨å–å…ƒç´ çš„æƒå€¼æ’åˆ—ï¼Œç¡®çœæƒ…å†µä¸‹åˆ©ç”¨ä¸€ä¸ªmax-heapå®Œæˆï¼Œåè€…æ˜¯ä»¥vectorâ€”è¡¨ç°çš„å®Œå…¨äºŒå‰æ ‘ã€‚

```cpp
template<class T, class Sequence=vector <T>, class Compare=less<typename Sequence::value_type>>
class priority_queue {
public:

    typedef typename Sequence::value_type value_type;
    typedef typename Sequence::size_type size_type;
    typedef typename Sequence::reference reference;
    typedef typename Sequence::const_reference const_refernece;

protected:

    Sequence c;//åº•å±‚å®¹å™¨
    Compare comp//å®¹å™¨æ¯”è¾ƒå¤§å°æ ‡å‡†

public:

    priority_queue() : c() {}
    explicit priority_queue(const Compare &x) : c(), comp(x) {}
    //ä»¥ä¸‹ç”¨åˆ°çš„make_heap(),push_heap(),pop_heap()éƒ½æ˜¯æ³›å‹ç®—æ³•

    //ä»»ä½•ä¸€ä¸ªæ„é€ å‡½æ•°éƒ½å¯ä»¥ç«‹å³åœ¨åº•å±‚äº§ç”Ÿä¸€ä¸ªheap
    template<class InputIterator>
    priority_queue(InputIterator first, InputIterator last const Compare &x)
            :c(first, last), comp(x) { make_heap(c.begin(), c.end(), comp); }

    template<class InputIterator>
    priority_queue(InputIterator first, InputIterator last const Compare &x)
            :c(first, last) { make_heap(c.begin(), c.end(), comp); }

    bool empty() const { return c.empty(); }
    size_type size() const { return c.size(); }
    const_reference top() const { return c.front(); }
    void push(const value_type &x) {
        _STL_TRy {
            c.push_back(X);
            push_heap(c.begin(), c.end(), comp);
        }
        _STL_UNWIND{c.clear()};
    }

    void pop() {
        _STL_TRY {
            pop_heap(c.begin(), c.end(), comp);
            c.pop_back();
        }
        _STL_UNWEIND{c.clear()};
    }
};

// priority_queueæ— è¿­ä»£å™¨

```

## map && setçš„åŒºåˆ«å’Œå®ç°åŸç†

mapå†…éƒ¨å®ç°äº†ä¸€ä¸ª**çº¢é»‘æ ‘**ï¼ˆçº¢é»‘æ ‘æ˜¯éä¸¥æ ¼å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘ï¼Œè€ŒAVLæ˜¯ä¸¥æ ¼å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼‰ï¼Œçº¢é»‘æ ‘æœ‰è‡ªåŠ¨æ’åºçš„åŠŸèƒ½ï¼Œå› æ­¤mapå†…éƒ¨æ‰€æœ‰å…ƒç´ éƒ½æ˜¯æœ‰åºçš„ï¼Œçº¢é»‘æ ‘çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éƒ½ä»£è¡¨ç€mapçš„ä¸€ä¸ªå…ƒç´ ã€‚å› æ­¤ï¼Œå¯¹äºmapè¿›è¡Œçš„æŸ¥æ‰¾ã€åˆ é™¤ã€æ·»åŠ ç­‰ä¸€ç³»åˆ—çš„æ“ä½œéƒ½ç›¸å½“äºæ˜¯å¯¹çº¢é»‘æ ‘è¿›è¡Œçš„æ“ä½œã€‚mapä¸­çš„å…ƒç´ æ˜¯æŒ‰ç…§äºŒå‰æ ‘ï¼ˆåˆåäºŒå‰æŸ¥æ‰¾æ ‘ã€äºŒå‰æ’åºæ ‘ï¼‰å­˜å‚¨çš„ï¼Œç‰¹ç‚¹å°±æ˜¯å·¦å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„é”®å€¼éƒ½å°äºæ ¹èŠ‚ç‚¹çš„é”®å€¼ï¼Œå³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„é”®å€¼éƒ½å¤§äºæ ¹èŠ‚ç‚¹çš„é”®å€¼ã€‚ä½¿ç”¨ä¸­åºéå†å¯å°†é”®å€¼æŒ‰ç…§ä»å°åˆ°å¤§éå†å‡ºæ¥ã€‚

**å…±åŒç‚¹ï¼š**

éƒ½æ˜¯C++çš„å…³è”å®¹å™¨,åªæ˜¯é€šè¿‡å®ƒæä¾›çš„æ¥å£å¯¹é‡Œé¢çš„å…ƒç´ è¿›è¡Œè®¿é—®ï¼Œåº•å±‚éƒ½æ˜¯é‡‡ç”¨çº¢é»‘æ ‘å®ç°ã€‚

**ä¸åŒç‚¹ï¼š**

setï¼šç”¨æ¥åˆ¤æ–­æŸä¸€ä¸ªå…ƒç´ æ˜¯ä¸æ˜¯åœ¨ä¸€ä¸ªç»„é‡Œé¢ã€‚

mapï¼šæ˜ å°„ï¼Œç›¸å½“äºå­—å…¸ï¼ŒæŠŠä¸€ä¸ªå€¼æ˜ å°„æˆå¦ä¸€ä¸ªå€¼ï¼Œå¯ä»¥åˆ›å»ºå­—å…¸ã€‚

**ä¼˜ç‚¹ï¼š**

æŸ¥æ‰¾æŸä¸€ä¸ªæ•°çš„æ—¶é—´ä¸ºO(logn)ï¼›éå†æ—¶é‡‡ç”¨iteratorï¼Œæ•ˆæœä¸é”™ã€‚

**ç¼ºç‚¹ï¼š**

æ¯æ¬¡æ’å…¥å€¼çš„æ—¶å€™ï¼Œéƒ½éœ€è¦è°ƒæ•´çº¢é»‘æ ‘ï¼Œæ•ˆç‡æœ‰ä¸€å®šå½±å“ã€‚

**ç»†èŠ‚**

**1ã€ä¸ºä»€ä¹ˆè¦æˆå€çš„æ‰©å®¹è€Œä¸æ˜¯ä¸€æ¬¡å¢åŠ ä¸€ä¸ªå›ºå®šå¤§å°çš„å®¹é‡å‘¢ï¼Ÿ**

é‡‡ç”¨æˆå€æ–¹å¼æ‰©å®¹ï¼Œå¯ä»¥ä¿è¯å¸¸æ•°çš„æ—¶é—´å¤æ‚åº¦ï¼Œè€Œå¢åŠ æŒ‡å®šå¤§å°çš„å®¹é‡åªèƒ½è¾¾åˆ°O(n)çš„æ—¶é—´å¤æ‚åº¦ã€‚

**2ã€ä¸ºä»€ä¹ˆæ˜¯ä»¥ä¸¤å€çš„æ–¹å¼æ‰©å®¹è€Œä¸æ˜¯ä¸‰å€å››å€ï¼Œæˆ–è€…å…¶ä»–æ–¹å¼å‘¢**

è€ƒè™‘å¯èƒ½äº§ç”Ÿçš„å †ç©ºé—´æµªè´¹ï¼Œæ‰€ä»¥å¢é•¿å€æ•°ä¸èƒ½å¤ªå¤§ï¼Œä¸€èˆ¬æ˜¯1.5æˆ–2ï¼›GCCæ˜¯2ï¼›VSæ˜¯1.5ï¼Œk =2 æ¯æ¬¡æ‰©å±•çš„æ–°å°ºå¯¸å¿…ç„¶åˆšå¥½å¤§äºä¹‹å‰åˆ†é…çš„æ€»å’Œï¼Œä¹‹å‰åˆ†é…çš„å†…å­˜ç©ºé—´ä¸å¯èƒ½è¢«ä½¿ç”¨ï¼Œè¿™æ ·å¯¹äºç¼“å­˜å¹¶ä¸å‹å¥½ï¼Œé‡‡ç”¨1.5å€çš„å¢é•¿æ–¹å¼å¯ä»¥æ›´å¥½çš„å®ç°å¯¹å†…å­˜çš„é‡å¤åˆ©ç”¨ã€‚

**C++å¹¶æ²¡æœ‰è§„å®šæ‰©å®¹å› å­Kï¼Œè¿™æ˜¯ç”±æ ‡å‡†åº“çš„å®ç°è€…å†³å®šçš„ã€‚**

## map && unordered_mapçš„åŒºåˆ«

mapä¸­å…ƒç´ æ˜¯ä¸€äº›key-valueå¯¹ï¼Œå…³é”®å­—èµ·ç´¢å¼•ä½œç”¨ï¼Œå€¼è¡¨ç¤ºå’Œç´¢å¼•ç›¸å…³çš„æ•°æ®ã€‚

**åº•å±‚å®ç°ï¼š**

mapåº•å±‚æ˜¯åŸºäºçº¢é»‘æ ‘å®ç°çš„ï¼Œå› æ­¤mapå†…éƒ¨å…ƒç´ æ’åˆ—æ˜¯æœ‰åºçš„ã€‚

è€Œunordered_mapåº•å±‚åˆ™æ˜¯åŸºäºå“ˆå¸Œè¡¨å®ç°çš„ï¼Œå› æ­¤å…¶å…ƒç´ çš„æ’åˆ—é¡ºåºæ˜¯æ‚ä¹±æ— åºçš„ã€‚

**mapï¼š**

**ä¼˜ç‚¹ï¼š**

æœ‰åºæ€§ï¼Œè¿™æ˜¯mapç»“æ„æœ€å¤§çš„ä¼˜ç‚¹ï¼Œå…¶å…ƒç´ çš„æœ‰åºæ€§åœ¨å¾ˆå¤šåº”ç”¨ä¸­éƒ½ä¼šç®€åŒ–å¾ˆå¤šçš„æ“ä½œã€‚

mapçš„æŸ¥æ‰¾ã€åˆ é™¤ã€å¢åŠ ç­‰ä¸€ç³»åˆ—æ“ä½œæ—¶é—´å¤æ‚åº¦ç¨³å®šï¼Œéƒ½ä¸ºO(logn )ã€‚

**ç¼ºç‚¹ï¼š**

æŸ¥æ‰¾ã€åˆ é™¤ã€å¢åŠ ç­‰æ“ä½œå¹³å‡æ—¶é—´å¤æ‚åº¦è¾ƒæ…¢ï¼Œä¸nç›¸å…³ã€‚

**unordered_mapï¼š**

**ä¼˜ç‚¹ï¼š**

æŸ¥æ‰¾ã€åˆ é™¤ã€æ·»åŠ çš„é€Ÿåº¦å¿«ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºå¸¸æ•°çº§O(1ï¼‰ã€‚

**ç¼ºç‚¹ï¼š**

å› ä¸ºunordered_mapå†…éƒ¨åŸºäºå“ˆå¸Œè¡¨ï¼Œä»¥ï¼ˆkey,valueï¼‰å¯¹çš„å½¢å¼å­˜å‚¨ï¼Œå› æ­¤ç©ºé—´å ç”¨ç‡é«˜ã€‚

unordered_mapçš„æŸ¥æ‰¾ã€åˆ é™¤ã€æ·»åŠ çš„æ—¶é—´å¤æ‚åº¦ä¸ç¨³å®šï¼Œå¹³å‡ä¸ºO(1)ï¼Œå–å†³äºå“ˆå¸Œå‡½æ•°ã€‚æç«¯æƒ…å†µä¸‹å¯èƒ½ä¸ºO(n)ã€‚

**é—®é¢˜ï¼š**

ä¸ºä»€ä¹ˆinsertä¹‹åï¼Œä»¥å‰ä¿å­˜çš„iteratorä¸ä¼šå¤±æ•ˆï¼Ÿ

å› ä¸º map å’Œ set å­˜å‚¨çš„æ˜¯ç»“ç‚¹ï¼Œä¸éœ€è¦å†…å­˜æ‹·â»‰å’Œå†…å­˜ç§»åŠ¨ã€‚ä½†æ˜¯åƒ vector åœ¨æ’å…¥æ•°æ®æ—¶å¦‚æœå†…å­˜ä¸å¤Ÿä¼šé‡æ–°å¼€è¾Ÿä¸€å—å†…å­˜ã€‚map å’Œ set çš„ iterator æŒ‡å‘çš„æ˜¯èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œvector æŒ‡å‘çš„æ˜¯å†…å­˜çš„æŸä¸ªä½ç½®

ä¸ºä½•mapå’Œsetçš„æ’â¼Šåˆ é™¤æ•ˆç‡â½å…¶ä»–åºåˆ—å®¹å™¨â¾¼ï¼Ÿ

å› ä¸º map å’Œ set åº•éƒ¨ä½¿ç”¨çº¢é»‘æ ‘å®ç°ï¼Œæ’å…¥å’Œåˆ é™¤çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(logn)ï¼Œè€Œå‘ vector è¿™æ ·çš„åºåˆ—å®¹å™¨æ’å…¥å’Œåˆ é™¤çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(N)

## push_back å’Œ emplace_back çš„åŒºåˆ«

1. `push_back`Â ç”¨äºåœ¨å®¹å™¨çš„å°¾éƒ¨æ·»åŠ ä¸€ä¸ªå…ƒç´ ã€‚
```cpp
container.push_back(value);
```

`container`Â æ˜¯ä¸€ä¸ªæ”¯æŒÂ `push_back`Â æ“ä½œçš„å®¹å™¨ï¼Œä¾‹å¦‚Â `std::vector`ã€`std::list`Â ç­‰ï¼Œè€ŒÂ `value`Â æ˜¯è¦æ·»åŠ çš„å…ƒç´ çš„å€¼ã€‚

2. `emplace_back`Â ç”¨äºåœ¨å®¹å™¨çš„å°¾éƒ¨ç›´æ¥æ„é€ ä¸€ä¸ªå…ƒç´ ã€‚

```cpp
container.emplace_back(args);
```

å…¶ä¸­Â `container`Â æ˜¯ä¸€ä¸ªæ”¯æŒÂ `emplace_back`Â æ“ä½œçš„å®¹å™¨ï¼Œè€ŒÂ `args`Â æ˜¯ä¼ é€’ç»™å…ƒç´ ç±»å‹çš„æ„é€ å‡½æ•°çš„å‚æ•°ã€‚ä¸Â `push_back`Â ä¸åŒçš„æ˜¯ï¼Œ`emplace_back`Â ä¸éœ€è¦åˆ›å»ºä¸´æ—¶å¯¹è±¡ï¼Œè€Œæ˜¯ç›´æ¥åœ¨å®¹å™¨ä¸­æ„é€ æ–°çš„å…ƒç´ ã€‚

åŒºåˆ«ï¼š

- `push_back`Â æ¥å—ä¸€ä¸ªå·²å­˜åœ¨çš„å¯¹è±¡æˆ–ä¸€ä¸ªå¯è½¬æ¢ä¸ºå®¹å™¨å…ƒç´ ç±»å‹çš„å¯¹è±¡ï¼Œå¹¶å°†å…¶å¤åˆ¶æˆ–ç§»åŠ¨åˆ°å®¹å™¨ä¸­ã€‚`emplace_back`Â ç›´æ¥åœ¨å®¹å™¨ä¸­æ„é€ å…ƒç´ ï¼Œä¸éœ€è¦åˆ›å»ºä¸´æ—¶å¯¹è±¡ã€‚
- `emplace_back`Â é€šå¸¸æ¯”Â `push_back`Â æ›´é«˜æ•ˆï¼Œå› ä¸ºå®ƒé¿å…äº†åˆ›å»ºå’Œé”€æ¯ä¸´æ—¶å¯¹è±¡çš„å¼€é”€ã€‚
- `emplace_back`Â çš„å‚æ•°æ˜¯ä¼ é€’ç»™å…ƒç´ ç±»å‹çš„æ„é€ å‡½æ•°çš„å‚æ•°ï¼Œè€ŒÂ `push_back`Â ç›´æ¥æ¥å—ä¸€ä¸ªå…ƒç´ ã€‚

```cpp
#include <vector>
#include <string>

int main() {
    std::vector<int> numbers;

    // ä½¿ç”¨ push_back
    numbers.push_back(42);

    // ä½¿ç”¨ emplace_back
    numbers.emplace_back(3, 4, 5);  // é€šè¿‡æ„é€ å‡½æ•°å‚æ•°ç›´æ¥æ„é€ å…ƒç´ 

    return 0;
}
```

## vectorçš„å®ç°åŸç†

`std::vector`Â æ˜¯C++æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªåŠ¨æ€æ•°ç»„å®ç°ï¼Œå®ƒçš„å®ç°åŸç†åŸºäºæ•°ç»„æ•°æ®ç»“æ„ã€‚å®ç°é€šå¸¸åŒ…å«ä¸€ä¸ªæŒ‡å‘æ•°ç»„èµ·å§‹ä½ç½®çš„æŒ‡é’ˆã€æ•°ç»„çš„å¤§å°å’Œå®¹é‡ç­‰ä¿¡æ¯ã€‚

åœ¨å°¾éƒ¨è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œæ—¶ï¼Œåªéœ€è°ƒæ•´å°¾éƒ¨æŒ‡é’ˆï¼Œä¸éœ€è¦ç§»åŠ¨æ•´ä¸ªæ•°æ®å—ã€‚

å½“å…ƒç´ æ•°é‡è¾¾åˆ°å½“å‰å†…å­˜å—çš„å®¹é‡æ—¶ï¼Œ`std::vector`Â ä¼šç”³è¯·ä¸€ä¸ªæ›´å¤§çš„å†…å­˜å—ï¼Œå°†å…ƒç´ ä»æ—§çš„å†…å­˜å—å¤åˆ¶åˆ°æ–°çš„å†…å­˜å—ï¼Œå¹¶é‡Šæ”¾æ—§çš„å†…å­˜å—ã€‚

ç”±äºæ•°ç»„çš„è¿ç»­å†…å­˜ç»“æ„ï¼Œé€šè¿‡ç´¢å¼•è¿›è¡Œè®¿é—®æ—¶å¯ä»¥é€šè¿‡æŒ‡é’ˆè¿ç®—å®ç°å¸¸æ•°æ—¶é—´å¤æ‚åº¦çš„éšæœºè®¿é—®ã€‚

```cpp
template <class T, class Allocator = std::allocator<T>>
class vector {
private:
    T* elements;  // æŒ‡å‘æ•°ç»„èµ·å§‹ä½ç½®çš„æŒ‡é’ˆ
    size_t size;   // å½“å‰å…ƒç´ æ•°é‡
    size_t capacity;  // å½“å‰åˆ†é…çš„å†…å­˜å—å®¹é‡
};
```

## listçš„å®ç°åŸç†

`std::list`Â æ˜¯C++æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªåŒå‘é“¾è¡¨å®ç°ï¼Œå®ƒçš„å®ç°åŸç†åŸºäºé“¾è¡¨æ•°æ®ç»“æ„ã€‚æ¯ä¸ªèŠ‚ç‚¹åŒ…å«ä¸¤ä¸ªæŒ‡é’ˆï¼Œåˆ†åˆ«æŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹å’Œåä¸€ä¸ªèŠ‚ç‚¹, ä»¥åŠå­˜å‚¨å®é™…æ•°æ®çš„éƒ¨åˆ†ã€‚

```cpp
template <class T>
struct Node {
    T data;
    Node* prev;
    Node* next;
};
```

`std::list`Â ç»´æŠ¤ä¸€ä¸ªå¤´æŒ‡é’ˆå’Œä¸€ä¸ªå°¾æŒ‡é’ˆï¼Œå®ƒä»¬åˆ†åˆ«æŒ‡å‘é“¾è¡¨çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªèŠ‚ç‚¹ã€‚

åœ¨æ’å…¥å’Œåˆ é™¤æ“ä½œæ—¶ï¼Œåªéœ€è°ƒæ•´ç›¸é‚»èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œä¸éœ€è¦ç§»åŠ¨æ•´ä¸ªæ•°æ®å—ã€‚

## vectorå’Œlistçš„åŒºåˆ«

1. å®ç°ä¸Š

- `vector`ä½¿ç”¨åŠ¨æ€æ•°ç»„å®ç°ã€‚è¿ç»­çš„å†…å­˜å—ï¼Œæ”¯æŒéšæœºè®¿é—®ã€‚åœ¨å°¾éƒ¨è¿›è¡Œæ’å…¥/åˆ é™¤æ“ä½œè¾ƒå¿«ï¼Œä½†åœ¨ä¸­é—´æˆ–å¤´éƒ¨è¿›è¡Œæ’å…¥/åˆ é™¤å¯èƒ½ä¼šæ¶‰åŠå¤§é‡å…ƒç´ çš„ç§»åŠ¨ã€‚
- `list`ä½¿ç”¨åŒå‘é“¾è¡¨å®ç°ã€‚ä¸è¿ç»­çš„å†…å­˜å—ï¼Œä¸æ”¯æŒéšæœºè®¿é—®ã€‚åœ¨ä»»æ„ä½ç½®è¿›è¡Œæ’å…¥/åˆ é™¤æ“ä½œéƒ½æ˜¯å¸¸æ•°æ—¶é—´å¤æ‚åº¦ã€‚

2. è®¿é—®ä¸Š

- vectoræ”¯æŒé€šè¿‡ç´¢å¼•è¿›è¡Œå¿«é€Ÿéšæœºè®¿é—®ã€‚ä½¿ç”¨è¿­ä»£å™¨è¿›è¡Œè®¿é—®æ—¶ï¼Œæ•ˆç‡è¾ƒé«˜ã€‚
- Listä¸æ”¯æŒé€šè¿‡ç´¢å¼•è¿›è¡Œå¿«é€Ÿéšæœºè®¿é—®ã€‚è¿­ä»£å™¨åœ¨è®¿é—®æ—¶éœ€è¦éå†é“¾è¡¨ï¼Œæ•ˆç‡ç›¸å¯¹è¾ƒä½ã€‚

3. æ’å…¥å’Œåˆ é™¤æ“ä½œ

- **vectorï¼š**åœ¨å°¾éƒ¨è¿›è¡Œæ’å…¥/åˆ é™¤æ“ä½œæ˜¯å¸¸æ•°æ—¶é—´å¤æ‚åº¦ã€‚åœ¨ä¸­é—´æˆ–å¤´éƒ¨è¿›è¡Œæ’å…¥/åˆ é™¤å¯èƒ½æ¶‰åŠå¤§é‡å…ƒç´ çš„ç§»åŠ¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºçº¿æ€§ã€‚
- List: åœ¨ä»»æ„ä½ç½®è¿›è¡Œæ’å…¥/åˆ é™¤æ“ä½œéƒ½æ˜¯å¸¸æ•°æ—¶é—´å¤æ‚åº¦ï¼Œå› ä¸ºåªéœ€è°ƒæ•´ç›¸é‚»èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚

4. å†…å­˜ç®¡ç†

- Vectorä½¿ç”¨åŠ¨æ€æ•°ç»„ï¼Œéœ€è¦åœ¨é¢„ä¼°å…ƒç´ æ•°é‡æ—¶åˆ†é…ä¸€å—è¾ƒå¤§çš„å†…å­˜ç©ºé—´ã€‚
- listç”±äºé‡‡ç”¨é“¾è¡¨ç»“æ„ï¼ŒåŠ¨æ€åˆ†é…çš„å†…å­˜æ¯”è¾ƒçµæ´»ã€‚æ¯ä¸ªå…ƒç´ éƒ½æœ‰è‡ªå·±çš„å†…å­˜å—ï¼Œé¿å…äº†é¢„åˆ†é…çš„é—®é¢˜ã€‚

5. é€‚ç”¨åœºæ™¯

- Vectoré€‚ç”¨äºéœ€è¦é¢‘ç¹éšæœºè®¿é—®ã€åœ¨å°¾éƒ¨è¿›è¡Œæ’å…¥/åˆ é™¤æ“ä½œçš„åœºæ™¯ã€‚
- listé€‚ç”¨äºéœ€è¦é¢‘ç¹åœ¨ä¸­é—´æˆ–å¤´éƒ¨è¿›è¡Œæ’å…¥/åˆ é™¤æ“ä½œã€ä¸è¦æ±‚éšæœºè®¿é—®çš„åœºæ™¯ã€‚

## è¿­ä»£å™¨æœ‰ä»€ä¹ˆä½œç”¨ï¼Ÿä»€ä¹ˆæ—¶å€™è¿­ä»£å™¨ä¼šå¤±æ•ˆ

è¿­ä»£å™¨ä¸ºä¸åŒç±»å‹çš„å®¹å™¨æä¾›äº†ç»Ÿä¸€çš„è®¿é—®æ¥å£ï¼Œ éšè—äº†åº•å±‚å®¹å™¨çš„å…·ä½“å®ç°ç»†èŠ‚ï¼Œ å…è®¸å¼€å‘è€…ä½¿ç”¨ä¸€è‡´çš„è¯­æ³•æ¥æ“ä½œä¸åŒç±»å‹çš„å®¹å™¨ã€‚

- å¯¹äºåºåˆ—å®¹å™¨vectorï¼Œdequeæ¥è¯´ï¼Œä½¿ç”¨eraseåï¼Œåè¾¹çš„æ¯ä¸ªå…ƒç´ çš„è¿­ä»£å™¨éƒ½ä¼šå¤±æ•ˆï¼Œåè¾¹æ¯ä¸ªå…ƒç´ éƒ½å¾€å‰ç§»åŠ¨ä¸€ä½ï¼Œeraseè¿”å›ä¸‹ä¸€ä¸ªæœ‰æ•ˆçš„è¿­ä»£å™¨ã€‚
- å¯¹äºå…³è”å®¹å™¨mapï¼Œsetæ¥è¯´ï¼Œä½¿ç”¨äº†eraseåï¼Œå½“å‰å…ƒç´ çš„è¿­ä»£å™¨å¤±æ•ˆï¼Œä½†æ˜¯å…¶ç»“æ„æ˜¯çº¢é»‘æ ‘ï¼Œåˆ é™¤å½“å‰å…ƒç´ ï¼Œä¸ä¼šå½±å“ä¸‹ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ï¼Œæ‰€ä»¥åœ¨è°ƒç”¨eraseä¹‹å‰ï¼Œè®°å½•ä¸‹ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨å³å¯ã€‚
- å¯¹äºlistæ¥è¯´ï¼Œå®ƒä½¿ç”¨äº†ä¸è¿ç»­åˆ†é…çš„å†…å­˜ï¼Œå¹¶ä¸”å®ƒçš„eraseæ–¹æ³•ä¹Ÿä¼šè¿”å›ä¸‹ä¸€ä¸ªæœ‰æ•ˆçš„è¿­ä»£å™¨ï¼Œå› æ­¤ä¸Šé¢ä¸¤ç§æ–¹æ³•éƒ½å¯ä»¥ä½¿ç”¨ã€‚