
# 🎯 选择排序 (Selection Sort)

> **归档**: #Algorithm #Sorting #Elementary
> 
> **核心心法**: "狙击手" —— 瞄准乱堆里最小的那个，一枪带走。

## 🧠 核心思想
它的工作原理是每一次从待排序的数据元素中选出**最小**（或最大）的一个元素，存放在序列的起始位置。
- 每一轮只做**一次**交换（或者不交换）。
- 无论数组多乱或多有序，它都要老老实实扫描一遍。

## 🎨 图解演示

<SelectionSortAnimation />

```mermaid
graph TD
    subgraph Round 1
    A[5, 3, 8, 4, 2] -->|全场扫描找最小| B(发现 2 是最小的)
    B -->|位置 0 的 5 和 2 交换| C[2, 3, 8, 4, 5]
    end
    subgraph Round 2
    C -->|从剩下里找最小| D(发现 3 是最小的)
    D -->|位置 1 的 3 原地不动| E[2, 3, 8, 4, 5]
    end
    style C fill:#9f6,stroke:#333
````

## 💻 代码实现 (C++)


```cpp
void selectionSort(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i; // 假设当前位置 i 就是最小的
        
        // 🔭 在后面剩下的堆里找个更小的
        for (int j = i + 1; j < n; j++) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j; // 更新最小值的下标
            }
        }
        
        // 找到了真正的最小(minIndex)，把它换到前面(i)来
        swap(nums[i], nums[minIndex]);
    }
}
```

## 📊 复杂度分析

|**维度**|**数值**|**说明**|
|---|---|---|
|**时间 (平均)**|$O(N^2)$|即使数组有序，也要 $N^2$ 次比较|
|**时间 (最好)**|$O(N^2)$|没得商量，它是“最诚实”的算法|
|**空间**|$O(1)$|原地交换|
|**稳定性**|❌ 不稳定|跨距离交换可能破坏相对顺序 (如 `5, 8, 5, 2` 交换第一个5和2)|

## 💡 适用场景

- **写操作非常昂贵时**：如果你交换数据的成本很高（写磁盘），选择排序是很好的选择，因为它最多只交换 $N$ 次（冒泡和插入可能交换 $N^2$ 次）。