
# 🃏 插入排序 (Insertion Sort)

> **归档**: #Algorithm #Sorting #Elementary
> 
> **核心心法**: "理扑克牌" —— 摸一张新牌，在手里已经排好的牌里找到位置插进去。

## 🧠 核心思想
将数组分为“已排序区间”和“未排序区间”。
- 每次从未排序区间取出一个元素（新牌）。
- 在已排序区间从后往前扫描，找到合适的位置插入。
- **越有序，越快！**

## 🎨 图解演示

<InsertionSortAnimation />

```mermaid
graph TD
    A[已排序: 2, 5, 8] -->|拿出新牌: 4| B{4 比 8 小?}
    B -- Yes --> C[8 后移: 2, 5, _, 8]
    C -->|4 比 5 小?| D{Yes}
    D --> E[5 后移: 2, _, 5, 8]
    E -->|4 比 2 小?| F{No}
    F --> G[填入 4: 2, 4, 5, 8]
    style A fill:#f9f,stroke:#333
````

## 💻 代码实现 (C++)


```cpp
void insertionSort(vector<int>& nums) {
    int n = nums.size();
    // 第 0 张牌默认是有序的，从第 1 张开始摸牌
    for (int i = 1; i < n; i++) {
        int key = nums[i]; // 🃏 摸起这张新牌
        int j = i - 1;     // 盯着它前面的那张牌
        
        // 只要前面的牌(j)比新牌(key)大，前面的牌就往后挪
        while (j >= 0 && nums[j] > key) {
            nums[j + 1] = nums[j]; // 往后挪一格
            j--; // 继续往前看
        }
        // 这里的 j+1 就是留出来的空位，把 key 插进去
        nums[j + 1] = key;
    }
}
```

## 📊 复杂度分析

|**维度**|**数值**|**说明**|
|---|---|---|
|**时间 (平均)**|$O(N^2)$|逆序时很慢|
|**时间 (最好)**|**$O(N)$**|数组基本有序时，几乎不用挪动，**飞快！**|
|**空间**|$O(1)$|原地操作|
|**稳定性**|✅ 稳定|只有严格大于才移动，相等的不动|

## 💡 适用场景

- **小规模数据**：当 $N < 16$ 时，它甚至比快排还快（STL `sort` 内部就这么干）。
    
- **基本有序的数组**：效率极高，甚至接近 $O(N)$。