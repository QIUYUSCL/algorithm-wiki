
# ⚡ 快速排序 (Quick Sort)

> **归档**: #Algorithm #Sorting #Advanced
> 
> **核心心法**: "分而治之" —— 选个老大划清界限，左边都是小弟，右边都是大哥。

## 🧠 核心思想 (前序遍历)
快排的本质是二叉树的**前序遍历**。
1.  **选基准 (Pivot)**：随机挑一个数。
2.  **切分 (Partition)**：把比基准小的扔左边，比基准大的扔右边。
3.  **递归 (Recursion)**：对左右两边重复上述过程，直到只剩一个元素。

## 🎨 图解演示

<QuickSortAnimation />

```mermaid
graph TD
    Root(数组: 5, 1, 9, 3, 7) -->|1. Partition Pivot=5| Split
    Split --> Left(左区: 1, 3)
    Split --> Pivot((基准: 5 归位))
    Split --> Right(右区: 9, 7)
    
    Left -->|2. 递归左边| L_Done(1, 3 有序)
    Right -->|3. 递归右边| R_Done(7, 9 有序)
    
    L_Done --> Result
    Pivot --> Result
    R_Done --> Result(最终: 1, 3, 5, 7, 9)
    style Pivot fill:#f96,stroke:#333
````

## 💻 代码实现 (C++ 随机化版)


```cpp
class Solution {
public:
    void quickSort(vector<int>& nums, int left, int right) {
        if (left >= right) return;
        
        // 1. 切分，并拿到基准归位后的下标
        int pIndex = partition(nums, left, right);
        
        // 2. 递归排左边
        quickSort(nums, left, pIndex - 1);
        // 3. 递归排右边
        quickSort(nums, pIndex + 1, right);
    }

    int partition(vector<int>& nums, int left, int right) {
        // 🎲 随机化优化：防御有序数组导致超时
        int randIdx = left + rand() % (right - left + 1);
        swap(nums[left], nums[randIdx]);
        
        int pivot = nums[left];
        int i = left + 1, j = right;
        
        while (true) {
            // 找左边的坏人（比 pivot 大的）
            while (i <= j && nums[i] < pivot) i++; // 若有重复元素，用 < 可让树更平衡
            // 找右边的坏人（比 pivot 小的）
            while (i <= j && nums[j] > pivot) j--;
            
            if (i >= j) break;
            swap(nums[i], nums[j]);
            i++; j--; 
        }
        swap(nums[left], nums[j]); // 基准归位
        return j;
    }
};
```

## 📊 复杂度分析

|**维度**|**数值**|**说明**|
|---|---|---|
|**时间 (平均)**|$O(N \log N)$|每次切分都减半|
|**时间 (最差)**|$O(N^2)$|每次都选到最大/最小值 (随机化可避免)|
|**空间**|$O(\log N)$|递归栈的深度|
|**稳定性**|❌ 不稳定|远距离交换破坏顺序|

## 💡 适用场景

- **通用排序**：C++ `std::sort`、Java `Arrays.sort` (基本类型) 的底层核心。
    
- **数组排序首选**：在内存足够的情况下，它是最快的通用排序。