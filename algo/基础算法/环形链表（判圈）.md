# [141] 环形链表 (Linked List Cycle)

> **标签**：`链表` `双指针` `快慢指针`  
> **难度**：🟢 Easy

## 🧠 核心思维：快慢指针 (Floyd 判圈算法)

> [!TIP]
> **物理直觉**：
> 在环形跑道上，跑得快的人（兔子）一定会从后面追上跑得慢的人（乌龟）。

* **快指针 (fast)**：每次走 **2** 步。
* **慢指针 (slow)**：每次走 **1** 步。

### 结局推演
1.  **无环**：Fast 指针会遇到 `nullptr` (直接冲过终点)。
2.  **有环**：Fast 指针一定会再次追上 Slow 指针，即 `fast == slow`。

---

## 💻 标准代码 (C++)

```cpp
bool hasCycle(ListNode *head) {
    // 特判：如果跑道都没修好，肯定没环
    if (head == nullptr || head->next == nullptr) return false;
    
    ListNode* slow = head;
    ListNode* fast = head;
    
    // > [!WARNING] 崩溃高发区
    // 兔子跑得快，必须保证：
    // 1. 兔子当前脚下有路 (fast != nullptr)
    // 2. 兔子跳的下一步也有路 (fast->next != nullptr)
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;          // 🐢 慢走1步
        fast = fast->next->next;    // 🐇 快走2步
        
        if (slow == fast) {
            return true; // 💥 相遇即有环
        }
    }
    
    return false; // 🏃 跑到尽头即无环
}
```


## 📊 复杂度分析

> [!NOTE]
> 
> - **时间复杂度**：$O(N)$。如果有环，快慢指针在环内走的圈数是常数级的，不会无限死循环。
>     
> - **空间复杂度**：$O(1)$。我们只使用了 `slow` 和 `fast` 两个指针，没有使用哈希表。
>