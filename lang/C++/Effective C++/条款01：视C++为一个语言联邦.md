这个条款告诉你：不要把 C++ 视为单一的语言，而应该把它看作由**四种次语言**（sub-languages）组成的联邦。当你在不同的次语言之间切换时，高效编程的守则（Best Practices）也会随之改变。
### 1. 核心观点：C++ 的四个次语言
C++ 发展至今已经非常庞大，Meyers 建议将其划分为四个主要部分，每个部分都有自己的规矩：
- **C 语言 (C)**
    - **描述**：C++ 的基础。包括区块、语句、预处理器、内置数据类型（`int`, `double`, `char` 等）、数组、指针等。
    - **守则**：当你在使用这部分时，遵循 C 语言的规则（例如：通常使用**值传递** `pass-by-value` 比引用传递更高效）。
- **面向对象的 C++ (Object-Oriented C++)**
    - **描述**：这是 "C with Classes" 的部分。包括类（Classes）、封装、继承、多态、虚函数（动态绑定）等。
    - **守则**：在这部分，**引用传递**（`pass-by-reference-to-const`）通常比值传递更好（为了避免对象切割问题和昂贵的构造/析构成本）。
- **模板 C++ (Template C++)**
    - **描述**：C++ 的泛型编程部分。
    - **守则**：这部分规则非常特殊，甚至演化出了模板元编程（TMP）。在此领域中，不仅引用传递是主流，甚至类型推导等规则也完全不同。
- **STL (Standard Template Library)**
    - **描述**：标准模板库。包括容器（vector, list, map 等）、迭代器、算法和函数对象。
    - **守则**：STL 有其独特的约定。因为迭代器和函数对象是基于 C 指针建模的，所以在 STL 中，再次回到**值传递**（pass-by-value）通常是更好的选择。

### 2. 条款启示（Takeaway）
**没有一套通用的规则适用于整个 C++。**
你需要根据当前正在使用的“次语言”来调整你的编程策略：
- **例子**：对于内置类型（C 部分），`pass-by-value` 更高效；但对于自定义对象（Object-Oriented 部分），`pass-by-reference-to-const` 更高效；而对于 STL 迭代器（STL 部分），又回到 `pass-by-value`。
### 总结
当你编写 C++ 代码时，先问自己：**“我现在是在用这四个联邦中的哪一部分？”** 清楚了这一点，你就能自然地选择出最优的编程规范。