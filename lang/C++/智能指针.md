
# C++ 现代内存管理：智能指针详解

自 C++11 以来，`new` 和 `delete` 已经逐渐退出历史舞台。我们要拥抱 RAII。

## 1. std::unique_ptr (独占所有权)

这是最常用的智能指针。
- **特点**：同一时刻只能有一个指针拥有该对象。
- **性能**：几乎零开销（和裸指针一样快）。
- **不可复制**，只能**移动 (move)**。

```cpp
std::unique_ptr<int> p1 = std::make_unique<int>(10);
// std::unique_ptr<int> p2 = p1; // ❌ 编译报错！禁止复制
std::unique_ptr<int> p3 = std::move(p1); // ✅ 所有权转移给 p3，p1 变空
````

## 2. std::shared_ptr (共享所有权)

- **特点**：通过**引用计数 (Reference Counting)** 实现多个指针共用一个对象。
    
- **原理**：每多一个指向，计数 +1；析构一个，计数 -1。当计数为 0 时，释放内存。
    

::: danger 循环引用陷阱 (Circular Reference) 如果 A 对象存了 B 的 shared_ptr，B 对象又存了 A 的 shared_ptr，它们的引用计数永远不会降为 0，导致**内存泄漏**。 :::

## 3. std::weak_ptr (破除循环)

`weak_ptr` 是 `shared_ptr` 的小跟班。

- 它指向对象，但**不增加**引用计数。
    
- 专门用来解决循环引用问题。
    

**使用场景**：观察者模式、缓存表、解决父子节点相互引用的树结构。