
---
# 栈 (Stack) vs 堆 (Heap) 内存布局

> **核心摘要**：栈是自动管理的、有序的、快速的小块内存；堆是手动管理的、灵活的、稍慢的大块内存。

## 📊 内存布局图 (Memory Layout)

在典型的 C++ 程序中，虚拟内存空间从**高地址**到**低地址**的分布如下：

```
block-beta
  columns 1
  block:HighAddr["高地址 (0xFFFFFFFF)"]
    style HighAddr fill:#f9f9f9,stroke:#333,stroke-width:0px
  end

  block:StackBlock["Stack (栈区)"]
    StackText["局部变量、函数参数、返回地址"]
    space
    StackArrow["⬇️ 向低地址生长"]
    style StackBlock fill:#ffcccc,stroke:#333
  end

  block:FreeSpace["... 自由空间 ..."]
    style FreeSpace fill:#ffffff,stroke:#ccc,stroke-dasharray: 5 5
  end

  block:HeapBlock["Heap (堆区)"]
    HeapArrow["⬆️ 向高地址生长"]
    space
    HeapText["动态分配 (new/malloc)"]
    style HeapBlock fill:#ccffcc,stroke:#333
  end

  block:Data["Data / BSS (全局/静态区)"]
    DataText["全局变量、static 变量"]
    style Data fill:#ccccff,stroke:#333
  end

  block:Text["Text / Code (代码区)"]
    CodeText["二进制指令、常量字符串"]
    style Text fill:#e0e0e0,stroke:#333
  end

  block:LowAddr["低地址 (0x00000000)"]
    style LowAddr fill:#f9f9f9,stroke:#333,stroke-width:0px
  end
```

## 📝 详细原理解析

### 1. 栈 (Stack)

- **就像去饭堂打饭**：排队、打饭、吃完走人，流程固定，速度快。
- **管理方式**：**由编译器自动管理**。函数调用时分配，函数结束时自动释放。
- **存储内容**：局部变量（Local Variables）、函数参数、函数调用的上下文（返回地址）。
- **特点**：
    - **LIFO**（后进先出）结构。
    - **速度极快**：CPU 有专门的寄存器（ESP/EBP）处理栈指针，分配内存只需要移动指针。
    - **空间有限**：通常只有几 MB（如 Linux 默认 8MB）。如果递归太深或分配巨大数组，会报 `Stack Overflow`。

### 2. 堆 (Heap)
- **就像去图书馆借书**：你需要填单子（申请），自己去找书，看完还得自己还回去（释放），否则别人借不到。
- **管理方式**：**由程序员手动管理**。C++ 中使用 `new/delete`，C 中使用 `malloc/free`。
- **存储内容**：程序运行时动态分配的对象（比如读取文件内容、动态数组、链表节点）。
- **特点**：
    - **灵活**：想申请多少就申请多少（受物理内存限制）。
    - **速度较慢**：涉及到内存分配算法（寻找合适的空闲块），可能产生**内存碎片**。
    - **风险**：忘记释放会导致**内存泄漏 (Memory Leak)**，释放后继续使用会导致**悬空指针**。

## ⚔️ 深度对比 (VS)

|**特性**|**栈 (Stack)**|**堆 (Heap)**|
|---|---|---|
|**分配方式**|编译器自动分配/释放|程序员手动 `new`/`delete`|
|**空间大小**|小 (MB 级别)|大 (GB 级别，受硬件限制)|
|**分配效率**|**极快** (仅移动指针)|**较慢** (搜索空闲块、系统调用)|
|**生长方向**|向下 (高地址 -> 低地址)|向上 (低地址 -> 高地址)|
|**碎片化**|无 (连续内存)|有 (频繁申请释放产生碎片)|
|**生命周期**|随作用域 (Scope) 结束|直到手动释放或程序结束|
|**常见错误**|栈溢出 (Stack Overflow)|内存泄漏、Double Free|

## 💻 代码示例


```cpp
#include <iostream>

// 全局变量 -> Data 区
int globalVar = 100;

void func() {
    // 局部变量 -> Stack 区
    int stackVar = 10; 
    
    // 指针变量 p 本身 -> Stack 区
    // p 指向的 int(20) 对象 -> Heap 区
    int* p = new int(20); 

    std::cout << "Stack address: " << &stackVar << std::endl;
    std::cout << "Heap address:  " << p << std::endl;

    // 必须手动释放堆内存
    delete p; 
} // stackVar 在这里自动销毁，p 变量本身销毁
```






```
  高地址 (0xFFFFFFFF) ⬆️
+------------------------+ 
| [栈区 Stack]           | 🧊 局部变量、函数参数
| - - - - - - - - - - -  |    (自动管理)
|           ⬇️           |
|      (栈向下生长)      |
+------------------------+
|                        |
|                        |
|       自由空间         | 💨 (Stack 和 Heap 共用这块地盘)
|      (Free Space)      |    (谁用满了都会导致溢出)
|                        |
|                        |
+------------------------+
|      (堆向上生长)      |
|           ⬆️           |
| - - - - - - - - - - -  |    (手动管理)
| [堆区 Heap]            | 🔥 new / malloc 的对象
+------------------------+
| [全局/静态区 Data/BSS] | 💾 全局变量 (int g_a = 0)
+------------------------+
| [代码/常量区 Text]     | 📜 二进制代码、"Hello"字符串
+------------------------+
  低地址 (0x00000000) ⬇️
```

---


代码段

```
graph TD
    %% 定义样式
    classDef highAddr fill:#f9f9f9,stroke:none,color:#999;
    classDef stack fill:#ffcccc,stroke:#d00,stroke-width:2px;
    classDef free fill:#ffffff,stroke:#999,stroke-dasharray: 5 5;
    classDef heap fill:#ccffcc,stroke:#090,stroke-width:2px;
    classDef data fill:#ccccff,stroke:#00d,stroke-width:2px;
    classDef text fill:#e0e0e0,stroke:#333;
    classDef lowAddr fill:#f9f9f9,stroke:none,color:#999;
    classDef arrow fill:#fff,stroke:none;

    %% 节点定义
    High["🚩 高地址 (0xFFFFFFFF)"]:::highAddr
    
    subgraph StackZone [自动管理区]
        direction TB
        Stack["🧊 Stack (栈区)<br/>局部变量 / 函数调用"]:::stack
        ArrowDown["⬇️ 向下生长"]:::arrow
    end

    Free(("💨 自由空间<br/>(动态消长)")):::free

    subgraph HeapZone [手动管理区]
        direction BT
        ArrowUp["⬆️ 向上生长"]:::arrow
        Heap["🔥 Heap (堆区)<br/>new / malloc 分配"]:::heap
    end

    Data["💾 全局/静态区 (Data/BSS)<br/>static / global"]:::data
    Code["📜 代码/常量区 (Text)<br/>二进制指令 / 常量字符串"]:::text
    
    Low["🏁 低地址 (0x00000000)"]:::lowAddr

    %% 连接关系
    High --- StackZone
    Stack --- ArrowDown
    ArrowDown ~~~ Free
    Free ~~~ ArrowUp
    ArrowUp --- Heap
    HeapZone --- Data
    Data --- Code
    Code --- Low
```

### 为什么这样设计（核心解释）

在文档中配合图示，你可以加上这段简短的解释，帮助读者瞬间理解：

1. **两头堵**：代码和全局变量住在**楼下**（低地址，固定不动）；栈住在**楼顶**（高地址）。
    
2. **中间挤**：
    
    - **栈 (Stack)** 像是在楼顶往下**吊**东西，越吊越多。
        
    - **堆 (Heap)** 像是在楼下往上**盖**积木，越盖越高。
        
    - **自由空间**就是中间剩下的楼层。如果栈吊得太低，或者堆盖得太高，两者撞上了（或者把自由空间耗尽了），程序就崩了（OOM 或 StackOverflow）。
        

### 📝 更新建议

建议将上面的 **Mermaid 代码** 复制并替换掉你 `Stack_vs_Heap.md` 文件中原有的 Mermaid 代码块。如果你的 Markdown 渲染器对 Mermaid 支持一般，直接使用 **ASCII 文本图** 是最保险且专业的选择。